// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.3 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

// generated code start

#line 7 "src\parser.apd"

    module parser;

    import std.stdio;
    import std.file;
    import container;
#line 7 "src/nonterminals.apd"

    class Rule
    {
        uint index;
        NonTerminal 	nt;
        Symbol[]    	symbols,
                        param_symbols;
        string[uint]	errorMessages;
        uint[]          syncs;
        
        this(NonTerminal nt_, uint ind)
        {
            nt = nt_;
            nt.rules ~= this;
            index = ind;
        }
    }

    class NonTerminal
    {
        string          name;
        string[string]  attribs;
        Rule[]          rules;

        this(string n, string[string] attrs=null)
        {
            name = n;
            attribs = attrs;
        }
    }
#line 25 "src/basics.apd"

    class LexemeSet
    {
        Set!(string)    flm_lexemes,
                        imm_lexemes;
        uint[string]    indeces;

        void add(string regexp, bool immediate)
        {
            if ( immediate )
                imm_lexemes ~= regexp;
            else if ( !flm_lexemes.contains(regexp) )
            {
                flm_lexemes ~= regexp;
                uint index = indeces.length;
                indeces[regexp] = index;
            }
        }

        uint firstImmLexeme()
        {
            return flm_lexemes.length;
        }

        void buildIndeces()
        {
            auto next_index = flm_lexemes.length;
            foreach ( lex; imm_lexemes.elements )
                indeces[lex] = next_index++;
            assert(next_index <= FIRST_NT);
        }

        uint toSymbol(string lexeme)
        {
            auto index = lexeme in indeces;
            if ( index is null )
                return 0;
            return *index + FIRST_TOKEN;
        }
    }

    class NTSet
    {
        NonTerminal[]   nts;
        uint[string]    indeces;
        string[string]  param_table;
        uint            next_rule;

        Rule addRule(NonTerminal nt)
        {
            return new Rule(nt, next_rule++);
        }

        NonTerminal add(string name, string params=null, string[string] attribs=null)
        {
            NonTerminal nt;
            if ( (name in indeces) is null ) {
                indeces[name] = nts.length;
                nt = new NonTerminal(name, attribs);
                nts ~= nt;
                param_table[name] = params;
            }
            else
                nt = nts[indeces[name]];
            return nt;
        }

        NonTerminal ntFromName(string nt)
        {
            auto index = nt in indeces;
            if ( index is null )
                return null;
            return nts[*index];
        }

        Symbol toSymbol(string nt)
        {
            auto index = nt in indeces;
            if ( index is null )
                return 0;
            return cast(Symbol)*index + FIRST_NT;
        }
    }

    struct GrammarModule
    {
        string  module_name,
                file_name;
        SyntaxTree* root;
    }
    
    enum SemanticPhase
    {
        doAll,
        handleProlog,
        collectLexemes,
        collectDeclarations,
        generateLL,
        generateGrammar
    }

    class ParsingContext
    {
        SemanticPhase   phase;
        string          current_filename;

        GrammarModule[] imports;
        string[]        include_path;
        
        string[string]  properties;
        bool            add_line_directives;

        LexemeSet       main_lexemes,
                        ws_lexemes;
        NTSet           main_nts,
                        ws_nts;

        string          declaration,
                        startNT,
                        semantics,
                        llparser;

        this(string[] incp=null)
        {
            main_lexemes = new LexemeSet;
            ws_lexemes = new LexemeSet;
            main_nts = new NTSet;
            ws_nts = new NTSet;
            phase = SemanticPhase.doAll;

            include_path = incp;
            foreach ( ref ip; include_path )
            {
                if ( ip.length > 0 && ip[$-1] == '/' || ip[$-1] == '\\' )
                    ip = ip[0 .. $-1];
            }
            if ( include_path is null )
                include_path ~= ".";
        }

        Rule addRule(NonTerminal nt, bool is_whitespace)
        {
            return is_whitespace?ws_nts.addRule(nt):main_nts.addRule(nt);
        }

        string prop(string key)
        {
            auto val = key in properties;
            if ( val is null )
                return null;
            return *val;
        }

        void addLexeme(bool isws, string str, bool imm)
        {
            if ( isws )
                ws_lexemes.add(str, imm);
            else
                main_lexemes.add(str, imm);
        }
        
        uint symbolFromLexeme(bool isws, string str)
        {
            return isws?ws_lexemes.toSymbol(str):main_lexemes.toSymbol(str);
        }

        NonTerminal addNT(bool isws, string str, string params=null, string[string] attribs=null)
        {
            if ( isws )
                return ws_nts.add(str, params, attribs);
            return main_nts.add(str, params, attribs);
        }

        Symbol symbolFromNT(bool isws, string str)
        {
            return isws?ws_nts.toSymbol(str):main_nts.toSymbol(str);
        }

        NonTerminal ntFromName(bool isws, string name)
        {
            return isws?ws_nts.ntFromName(name):main_nts.ntFromName(name);
        }

        bool params(bool isws, string nt, out string params)
        {
            auto param_table = isws?ws_nts.param_table:main_nts.param_table;
            auto tmp = nt in param_table;
            if ( tmp is null )
                return false;
            if ( *tmp !is null )
                params = *tmp;
            return true;
        }

        string findModuleFile(string modname)
        {
            string relfn = replace(modname, ".", "/");
            foreach ( ip; include_path )
            {
                string filename = ip~"/"~relfn~".apd";
                if ( exists(filename) && isfile(filename) )
                    return filename;
            }
            return null;
        }
    }
// generated code end

import std.string;
debug import std.stdio;

/**************************************************************************************************
    Semantic Analyzer
**************************************************************************************************/

class SemanticException : Exception
{
    this(string msg)
    {
        super(msg);
    }
}

struct SyntaxTree
{
    uint            _ST_rule,
                    _ST_line_number;
    debug
    {
        string          _ST_node_name,
                        _ST_match,
                        _ST_match_ws;
        SyntaxTree*[]   _ST_children;
    }
    else
    {
        union
        {
            struct {
                string      _ST_match,
                            _ST_match_ws;
            }
            SyntaxTree*[]   _ST_children;
        }
    }

    debug
    {
        SyntaxTree* parent;

        string indent()
        {
            string str;
            for ( SyntaxTree* n = parent; n !is null; n = n.parent )
                str ~= "  ";
            return str;
        }

        void print(string indent = "")
        {
            writef("%s%s%d", indent, _ST_node_name, _ST_rule);
            if ( _ST_children.length == 0 )
                writefln(" (\"%s\")", _ST_match);
            else
                writefln;
            foreach ( c; _ST_children )
                c.print(indent~"  ");
        }
    }

    void opCatAssign(SyntaxTree* n)
    {
        _ST_children ~= n;
    }

    // augmented semantic code
// generated code start
    alias _S_Start Start;
void _S_Start(in string filename, ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 0:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Prolog = &_ST_children[0]._S_Prolog;
        void delegate(string filename, ref ParsingContext ctx) Grammar = &_ST_children[1]._S_Grammar;

#line 258 "src\parser.apd"

        ctx.current_filename = filename;
        if ( ctx.phase == SemanticPhase.doAll || ctx.phase == SemanticPhase.handleProlog )
            Prolog(ctx);
        if ( ctx.phase != SemanticPhase.handleProlog )
            Grammar(filename, ctx);
        break;

    default:
        assert(0);
    }
}
void _S_Prolog(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 1:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Prolog = &_ST_children[0]._S_Prolog;
        void delegate(out string value) FQIdent = &_ST_children[1]._S_FQIdent;

#line 273 "src\parser.apd"

        Prolog(ctx);
        string modname;
        FQIdent(modname);
        
        auto filename = ctx.findModuleFile(modname);
        if ( filename is null )
            throw new SemanticException(format("Cannot find module \"%s\" in include path", modname));
        string input = cast(string)read(filename);
        SyntaxTree* root;
        if ( parse(filename, input, root) ) {
            ctx.imports ~= GrammarModule(modname, filename, root);
            auto old_phase = ctx.phase;
            ctx.phase = SemanticPhase.handleProlog;
            root.Start(filename, ctx);
            ctx.phase = old_phase;
        }
        else
            throw new SemanticException(format("Error parsing %s", filename));
        break;
    case 2:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Prolog = &_ST_children[0]._S_Prolog;
        void delegate(ref ParsingContext ctx) Props = &_ST_children[1]._S_Props;

#line 299 "src\parser.apd"
 Prolog(ctx); Props(ctx);
        break;
    case 3:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Prolog = &_ST_children[0]._S_Prolog;
        void delegate(ref ParsingContext ctx) Lexs = &_ST_children[1]._S_Lexs;

#line 306 "src\parser.apd"
 Prolog(ctx); Lexs(ctx);
        break;
    case 4:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Prolog = &_ST_children[0]._S_Prolog;
        void delegate(out string dcode, out bool has_code, in bool includeBrackets=true) DCodeBlock = &_ST_children[1]._S_DCodeBlock;

#line 311 "src\parser.apd"

		Prolog(ctx);
        bool has_code;
        string decl;
        DCodeBlock(decl, has_code, false);
        if ( has_code )
        {
            if ( ctx.add_line_directives )
                ctx.declaration ~= format("\n#line %d \"%s\"\n%s", _ST_children[1]._ST_line_number, ctx.current_filename, decl);
            else
                ctx.declaration ~= decl;
        }
        break;
    case 5:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_Lexs(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 6:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Lexs = &_ST_children[0]._S_Lexs;
        void delegate(ref ParsingContext ctx) Lexeme = &_ST_children[1]._S_Lexeme;

#line 331 "src\parser.apd"
 Lexs(ctx); Lexeme(ctx);
        break;
    case 7:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx) Lexeme = &_ST_children[0]._S_Lexeme;

#line 334 "src\parser.apd"
 Lexeme(ctx);
        break;

    default:
        assert(0);
    }
}
void _S_Lexeme(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 8:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string escaped) StringTerminal = &_ST_children[0]._S_StringTerminal;

#line 340 "src\parser.apd"

        string value;
        StringTerminal(ctx, false, value);
        break;
    case 9:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string regexp, out bool immediate) RegExpTerminal = &_ST_children[0]._S_RegExpTerminal;

#line 346 "src\parser.apd"

        string value;
        bool immediate;
        RegExpTerminal(ctx, false, value, immediate);
        break;

    default:
        assert(0);
    }
}
void _S_Props(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 10:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) Props = &_ST_children[0]._S_Props;
        void delegate(ref ParsingContext ctx) Property = &_ST_children[1]._S_Property;

#line 356 "src\parser.apd"
 Props(ctx); Property(ctx);
        break;
    case 11:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx) Property = &_ST_children[0]._S_Property;

#line 359 "src\parser.apd"
 Property(ctx);
        break;

    default:
        assert(0);
    }
}
void _S_Property(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 12:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) Key = &_ST_children[0]._S_Ident;
        void delegate(out string value) Value = &_ST_children[1]._S_Ident;

#line 365 "src\parser.apd"

        string key, val;
        Key(key);
        Value(val);
        ctx.properties[key] = val;
        break;
    case 13:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) Key = &_ST_children[0]._S_Ident;
        void delegate(out string value) Value = &_ST_children[1]._S_QuotedString;

#line 373 "src\parser.apd"

        string key, val;
        Key(key);
        Value(val);
        ctx.properties[key] = val;
        break;

    default:
        assert(0);
    }
}
void _S_Grammar(string filename, ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 14:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx) NTs = &_ST_children[0]._S_NTs;

#line 384 "src\parser.apd"

        if ( ctx.phase == SemanticPhase.doAll )
        {
            ctx.phase = SemanticPhase.collectLexemes;
            NTs(ctx);
            foreach ( imp; ctx.imports )
                imp.root.Start(imp.file_name, ctx);
            ctx.current_filename = filename;
            
            ctx.main_lexemes.buildIndeces;
            ctx.ws_lexemes.buildIndeces;

            ctx.phase = SemanticPhase.collectDeclarations;
            NTs(ctx);
            foreach ( imp; ctx.imports )
                imp.root.Start(imp.file_name, ctx);
            ctx.current_filename = filename;

            if ( ctx.prop("parser_type") == "ll" || ctx.prop("parser_type") is null )
                ctx.phase = SemanticPhase.generateLL;
            else if ( ctx.prop("parser_type") == "lr" )
                ctx.phase = SemanticPhase.generateGrammar;
            else
                throw new SemanticException(format("Unknown parser type '%s'", ctx.prop("parser_type")));

            NTs(ctx);
            foreach ( imp; ctx.imports )
                imp.root.Start(imp.file_name, ctx);
            ctx.current_filename = filename;

            ctx.semantics = format("alias _S_%s %s;\n%s", ctx.startNT, ctx.startNT, ctx.semantics);
        }
        else
            NTs(ctx);
        break;

    default:
        assert(0);
    }
}
void _S_NTs(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 15:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx) NTs = &_ST_children[0]._S_NTs;
        void delegate(ref ParsingContext ctx) NT = &_ST_children[1]._S_NT;

#line 44 "src/nonterminals.apd"

        NTs(ctx);
        NT(ctx);
        break;
    case 16:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx) NT = &_ST_children[0]._S_NT;

#line 50 "src/nonterminals.apd"
 NT(ctx);
        break;

    default:
        assert(0);
    }
}
void _S_NT(ref ParsingContext ctx)
{

    switch ( _ST_rule )
    {
    case 17:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out string declCode, out bool hasEpsilon) NTBody = &_ST_children[1]._S_NTBody;

#line 56 "src/nonterminals.apd"

        string  name;
        Ident(name);

        if ( ctx.phase == SemanticPhase.collectDeclarations )
            ctx.addNT(true, name);
        else
        {
            string      pcode,
                        scode,
                        dcode;
            bool        hasEpsilon;
            NonTerminal nt = ctx.addNT(true, name);
            NTBody(ctx, nt, true, pcode, scode, dcode, hasEpsilon);

            if ( ctx.phase == SemanticPhase.generateLL )
            {
                ctx.llparser ~= "bool "~name~"(ref string input, ref uint lineNumber)\n{\n";
                ctx.llparser ~= pcode;
                if ( !hasEpsilon )
                    ctx.llparser ~= "\nreturn false;";
                ctx.llparser ~= "\n}\n";
            }
        }
        break;
    case 18:
        debug assert(_ST_children.length == 4);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;
        void delegate(out string params) DParametersOpt = &_ST_children[1]._S_DParametersOpt;
        void delegate(ref string[string] attribs) AttribsOpt = &_ST_children[2]._S_AttribsOpt;
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out string declCode, out bool hasEpsilon) NTBody = &_ST_children[3]._S_NTBody;

#line 85 "src/nonterminals.apd"

        string  name,
                params;
        Ident(name);
        DParametersOpt(params);

        if ( ctx.phase == SemanticPhase.collectDeclarations )
        {
            if ( ctx.startNT is null || ctx.startNT.length == 0 )
                ctx.startNT = name;
            string[string] attribs;
            AttribsOpt(attribs);
            ctx.addNT(false, name, params, attribs);
        }
        else
        {
            string      pcode,
                        scode,
                        dcode;
            bool        hasEpsilon;
            string[string]  attribs;
            AttribsOpt(attribs);
            NonTerminal nt = ctx.addNT(false, name, params, attribs);
            NTBody(ctx, nt, false, pcode, scode, dcode, hasEpsilon);

            if ( ctx.phase == SemanticPhase.generateLL )
            {
                ctx.llparser ~= "bool _P_"~name~"(SyntaxTree* node, ref string input, ref uint lineNumber, bool removeWS)\n{\n";
                ctx.llparser ~= "debug(parser) { bool success=true; writefln(\"%s"~name~" \\\"%s\\\"\", node.indent, escape(input[0..APDmin($,20u)])); ";
                ctx.llparser ~= "scope(exit) writefln(\"%s%s"~name~" \\\"%s\\\"\", node.indent, success?\"*\":\"-\", escape(input[0..APDmin($,20u)])); }\n"~pcode;
                if ( !hasEpsilon )
                    ctx.llparser ~= "\ndebug(parser) success = false; return false;";
                ctx.llparser ~= "\n}\n";
            }

            if ( ctx.phase == SemanticPhase.generateLL || ctx.phase == SemanticPhase.generateGrammar )
            {
                if ( ("no_ast" in nt.attribs) is null ) {
                    ctx.semantics ~= "void _S_"~name~"("~params~")\n{\n"~dcode~"\n    switch ( _ST_rule )\n    {\n";
                    ctx.semantics ~= scode~"\n    default:\n        assert(0);\n    }\n}\n";
                }
            }
        }
        break;

    default:
        assert(0);
    }
}
void _S_AttribsOpt(ref string[string] attribs)
{

    switch ( _ST_rule )
    {
    case 19:
        debug assert(_ST_children.length == 1);
        void delegate(ref string[string] attribs) Attributes = &_ST_children[0]._S_Attributes;

#line 134 "src/nonterminals.apd"
 Attributes(attribs);
        break;
    case 20:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_Attributes(ref string[string] attribs)
{

    switch ( _ST_rule )
    {
    case 21:
        debug assert(_ST_children.length == 2);
        void delegate(ref string[string] attribs) Attributes = &_ST_children[0]._S_Attributes;
        void delegate(out string value) Ident = &_ST_children[1]._S_Ident;

#line 142 "src/nonterminals.apd"

        Attributes(attribs);
        string tmp;
        Ident(tmp);
        attribs[tmp] = null;
        break;
    case 22:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;

#line 150 "src/nonterminals.apd"

        string tmp;
        Ident(tmp);
        attribs[tmp] = null;
        break;

    default:
        assert(0);
    }
}
void _S_NTBody(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out string declCode, out bool hasEpsilon)
{

    switch ( _ST_rule )
    {
    case 23:
        debug assert(_ST_children.length == 2);
        void delegate(out string dcode, out bool has_code, in bool includeBrackets=true) DCodeBlock = &_ST_children[0]._S_DCodeBlock;
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool hasEpsilon) Rules = &_ST_children[1]._S_Rules;

#line 164 "src/nonterminals.apd"

        if ( is_whitespace )
            throw new SemanticException("Declaration blocks are not allowed in whitespace non-terminals");
        if ( ctx.phase == SemanticPhase.generateLL || ctx.phase == SemanticPhase.generateGrammar )
        {
            bool has_code;
            DCodeBlock(declCode, has_code, false);
            if ( has_code && ctx.add_line_directives )
                declCode = format("\n#line %d \"%s\"\n%s", _ST_children[0]._ST_line_number, ctx.current_filename, declCode);
        }
        Rules(ctx, nt, is_whitespace, parserCode, semanticCode, hasEpsilon);
        break;
    case 24:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool hasEpsilon) Rules = &_ST_children[0]._S_Rules;

#line 180 "src/nonterminals.apd"

        Rules(ctx, nt, is_whitespace, parserCode, semanticCode, hasEpsilon);
        break;

    default:
        assert(0);
    }
}
void _S_DParametersOpt(out string params)
{

    switch ( _ST_rule )
    {
    case 25:
        debug assert(_ST_children.length == 1);
        void delegate(out string params) DParameters = &_ST_children[0]._S_DParameters;

#line 188 "src/nonterminals.apd"
 DParameters(params);
        break;
    case 26:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_DParameters(out string params)
{

    switch ( _ST_rule )
    {
    case 27:
        debug assert(_ST_children.length == 2);
        void delegate(out string params) DParameters = &_ST_children[0]._S_DParameters;
        void delegate(out string params) DParam = &_ST_children[1]._S_DParam;

#line 196 "src/nonterminals.apd"
 DParameters(params); string tmp; DParam(tmp); params ~= tmp;
        break;
    case 28:
        debug assert(_ST_children.length == 1);
        void delegate(out string params) DParam = &_ST_children[0]._S_DParam;

#line 199 "src/nonterminals.apd"
 DParam(params);
        break;

    default:
        assert(0);
    }
}
void _S_DParam(out string params)
{

    switch ( _ST_rule )
    {
    case 29:
        debug assert(_ST_children.length == 0);

#line 205 "src/nonterminals.apd"
 params = _ST_match_ws;
        break;

    default:
        assert(0);
    }
}
void _S_Rules(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool hasEpsilon)
{

    switch ( _ST_rule )
    {
    case 30:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool isEpsilon) Rule = &_ST_children[0]._S_Rule;
        void delegate(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool hasEpsilon) Rules = &_ST_children[1]._S_Rules;

#line 212 "src/nonterminals.apd"

        Rule(ctx, nt, is_whitespace, parserCode, semanticCode, hasEpsilon);
        string  pcode, scode;
        bool    hasEps;
        Rules(ctx, nt, is_whitespace, pcode, scode, hasEps);

        if ( hasEpsilon && pcode.length > 0 )
            throw new SemanticException(format("%s(%d): epsilon rule has to be last rule for non-terminal", ctx.current_filename, _ST_children[0]._ST_line_number));
        
        if ( ctx.phase == SemanticPhase.generateLL ) {
            hasEpsilon = hasEps || hasEpsilon;
            parserCode ~= "\n"~pcode;
        }
        if ( ctx.phase == SemanticPhase.generateLL || ctx.phase == SemanticPhase.generateGrammar )
        {
            if ( ("no_ast" in nt.attribs) is null )
                semanticCode ~= "\n"~scode;
        }
        break;
    case 31:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_Rule(ref ParsingContext ctx, NonTerminal nt, in bool is_whitespace,
    out string parserCode, out string semanticCode, out bool isEpsilon)
{

    switch ( _ST_rule )
    {
    case 32:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out bool isEpsilon, out string parserCode, ref string[] ntCalls) Symbols = &_ST_children[0]._S_Symbols;
        void delegate(bool is_whitespace, bool add_line_directives, string filename, out string dcode, out bool has_code) RuleBody = &_ST_children[1]._S_RuleBody;

#line 241 "src/nonterminals.apd"

        string[]    ntCalls;
        string      nestedCode;
        Rule        rule;
        if ( ctx.phase == SemanticPhase.generateLL || ctx.phase == SemanticPhase.generateGrammar )
            rule = ctx.addRule(nt, is_whitespace);
        Symbols(ctx, rule, is_whitespace, isEpsilon, nestedCode, ntCalls);

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            parserCode = "{\nstring tmpInput = input;\nuint tmpLineNumber = lineNumber;\n";

            if ( !is_whitespace )
            {
                parserCode ~= "if ( removeWS ) Whitespace(tmpInput, tmpLineNumber);\n"
                    ~ "SyntaxTree* n;\nn = new SyntaxTree; debug { n.parent = &node; n._ST_nodeName = \""~nt.name~"\"; }\n"
                    ~ "n._ST_rule = "~.toString(rule.index)~"; n._ST_line_number = tmpLineNumber;\n";
            }
            
            parserCode ~= nestedCode~"\n}";
        }

        if ( ("no_ast" in nt.attribs) is null && (ctx.phase == SemanticPhase.generateLL || ctx.phase == SemanticPhase.generateGrammar) )
        {
            string scode;
            bool has_code;
            RuleBody(is_whitespace, ctx.add_line_directives, ctx.current_filename, scode, has_code);
            semanticCode = "    case "~.toString(rule.index)~":\n";
            semanticCode ~= "        debug assert(_ST_children.length == "~.toString(ntCalls.length/2)~");\n";
            if ( has_code )
            {
                for ( int i; i < ntCalls.length; i+=2 )
                {
                    string  ntdecl = ntCalls[i],
                            ntalias = ntCalls[i+1],
                            params;
                    if ( !ctx.params(is_whitespace, ntdecl, params) )
                        throw new SemanticException(format("%s(%d): Semantical error: undeclared non-terminal %s", ctx.current_filename, _ST_line_number, ntdecl));
                    semanticCode ~= "        void delegate("~params~") "~ntalias~" = &_ST_children["~.toString(i/2)~"]._S_"~ntdecl~";\n";
                }
                semanticCode ~= scode~"\n";
            }
            semanticCode ~= "        break;";
        }
        break;

    default:
        assert(0);
    }
}
void _S_TerminalList(ref ParsingContext ctx, bool is_whitespace, ref string[] values)
{

    switch ( _ST_rule )
    {
    case 33:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx, bool is_whitespace, ref string[] values) TerminalList = &_ST_children[0]._S_TerminalList;
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string value) Terminal = &_ST_children[1]._S_Terminal;

#line 9 "src/symbols.apd"

        TerminalList(ctx, is_whitespace, values);
        string tmp;
        Terminal(ctx, is_whitespace, tmp);
        values ~= tmp;
        break;
    case 34:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string value) Terminal = &_ST_children[0]._S_Terminal;

#line 17 "src/symbols.apd"

        string tmp;
        Terminal(ctx, is_whitespace, tmp);
        values ~= tmp;
        break;

    default:
        assert(0);
    }
}
void _S_Terminal(ref ParsingContext ctx, bool is_whitespace, out string value)
{

    switch ( _ST_rule )
    {
    case 35:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string regexp, out bool immediate) RegExpTerminal = &_ST_children[0]._S_RegExpTerminal;

#line 27 "src/symbols.apd"

        bool immediate;
        RegExpTerminal(ctx, is_whitespace, value, immediate);
        break;
    case 36:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string escaped) StringTerminal = &_ST_children[0]._S_StringTerminal;

#line 34 "src/symbols.apd"
 StringTerminal(ctx, is_whitespace, value);
        break;

    default:
        assert(0);
    }
}
void _S_Symbols(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out bool isEpsilon, out string parserCode, ref string[] ntCalls)
{

    switch ( _ST_rule )
    {
    case 37:
        debug assert(_ST_children.length == 0);

#line 41 "src/symbols.apd"

        isEpsilon = true;
        if ( ctx.phase == SemanticPhase.generateLL )
        {
            parserCode = "input = tmpInput; lineNumber = tmpLineNumber;";
            if ( !is_whitespace )
                parserCode ~= " node ~= n;";
            parserCode ~= " return true;";
        }
        break;
    case 38:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string regexp, out bool immediate) RegExpTerminal = &_ST_children[0]._S_RegExpTerminal;

#line 53 "src/symbols.apd"

        string  regex;
        bool immediate;
        RegExpTerminal(ctx, is_whitespace, regex, immediate);

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( ctx.add_line_directives )
                parserCode = format("\n#line %d \"%s\"\n", _ST_line_number, ctx.current_filename);

            if ( is_whitespace )
            {
                if ( immediate )
                {
                    parserCode ~= "static RegExp re;\nif ( re is null )\nre = new RegExp(\""~regex~"\");\n";
                    parserCode ~= "if ( re.find(tmpInput) == 0 ) {\nlineNumber = tmpLineNumber + count(re.match(0), newlineString);\n";
                    parserCode ~= "input = tmpInput[re.match(0).length..$]; return true;\n}";
                }
                else
                {
                    parserCode ~= "if ( readSymbol(false, tmpInput, tmpLineNumber) == "~.toString(ctx.symbolFromLexeme(is_whitespace, regex))~" ) {\n";
                    parserCode ~= "input = tmpInput; return true;\n}";
                }
            }
            else
            {
                if ( immediate )
                {
                    parserCode ~= "static RegExp re;\nif ( re is null )\nre = new RegExp(\""~regex~"\");\n";
                    parserCode ~= "if ( removeWS ) Whitespace(tmpInput, tmpLineNumber);\nif ( re.find(tmpInput) == 0 ) {\n";
                    parserCode ~= "n._ST_match = re.match(0); lineNumber = tmpLineNumber + count(n._ST_match, newlineString);\n";
                    parserCode ~= "input = tmpInput[n._ST_match.length..$]; node ~= n; return true;\n}";
                }
                else
                {
                    parserCode ~= "if ( readSymbol(removeWS, tmpInput, tmpLineNumber, &n._ST_match) == "~.toString(ctx.symbolFromLexeme(is_whitespace, regex))~" ) {\n";
                    parserCode ~= "input = tmpInput; lineNumber = tmpLineNumber; node ~= n; return true;\n}";
                }
            }
        }
        else if ( ctx.phase == SemanticPhase.generateGrammar )
            rule.symbols ~= cast(Symbol)ctx.symbolFromLexeme(is_whitespace, regex);
        break;
    case 39:
        debug assert(_ST_children.length == 2);
        void delegate(out bool negate) NegateOpt = &_ST_children[0]._S_NegateOpt;
        void delegate(ref ParsingContext ctx, bool is_whitespace, ref string[] values) TerminalList = &_ST_children[1]._S_TerminalList;

#line 102 "src/symbols.apd"

        if ( ctx.prop("parser_type") == "ll" )
            throw new SemanticException(format("%s(%d): TerminalLists not implemented for LL parsers, yet", ctx.current_filename, _ST_line_number));

        string[] terminals;
        TerminalList(ctx, is_whitespace, terminals);

        if ( ctx.phase == SemanticPhase.generateGrammar )
        {
            LexemeSet lset = is_whitespace?ctx.ws_lexemes:ctx.main_lexemes;

            uint[] indeces = new uint[terminals.length];
            foreach ( i, term; terminals )
                indeces[i] = lset.toSymbol(term);
        
            rule.symbols ~= ALTERN;

            bool negate;
            NegateOpt(negate);
            if ( negate )
            {
                excludeLoop: foreach ( lex; lset.flm_lexemes.elements )
                {
                    auto sym = lset.toSymbol(lex);
                    foreach ( ind; indeces )
                    {
                        if ( sym == ind )
                            continue excludeLoop;
                    }
                    
                    rule.param_symbols ~= cast(Token)sym;
                }
            }
            else
            {
                foreach ( ind; indeces )
                    rule.param_symbols ~= cast(Token)ind;
            }
        }
        break;
    case 40:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) TNTSymbols = &_ST_children[0]._S_TNTSymbols;

#line 144 "src/symbols.apd"

        string	ignore,
				followingCutCode;
        TNTSymbols(ctx, rule, is_whitespace, parserCode, followingCutCode, ntCalls);
        if ( ctx.phase == SemanticPhase.generateLL )
            parserCode ~= followingCutCode;
        break;

    default:
        assert(0);
    }
}
void _S_NegateOpt(out bool negate)
{

    switch ( _ST_rule )
    {
    case 41:
        debug assert(_ST_children.length == 0);

#line 155 "src/symbols.apd"
 negate = true;
        break;
    case 42:
        debug assert(_ST_children.length == 0);

#line 156 "src/symbols.apd"
 negate = false;
        break;

    default:
        assert(0);
    }
}
void _S_TNTSymbols(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls)
{

    switch ( _ST_rule )
    {
    case 43:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) TNTSymbols = &_ST_children[0]._S_TNTSymbols;

#line 163 "src/symbols.apd"

        if ( is_whitespace )
            throw new SemanticException(format("%s(%d): KeepWS not allowed in Whitespace symbol in line", ctx.current_filename, _ST_line_number));
        TNTSymbols(ctx, rule, is_whitespace, ruleCode, cutCode, ntCalls);
        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( ctx.add_line_directives )
                ruleCode = format("\n#line %d \"%s\"", _ST_line_number, ctx.current_filename);
            ruleCode ~= "\nremoveWS = false;\n"~ruleCode;
        }
        else if ( ctx.phase == SemanticPhase.generateGrammar )
            throw new SemanticException(format("%s(%d): KeepWS may only be used in LL parsers", ctx.current_filename, _ST_line_number));
        break;
    case 44:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) TNTSymbols = &_ST_children[0]._S_TNTSymbols;

#line 178 "src/symbols.apd"

        if ( is_whitespace )
            throw new SemanticException(format("%s(%d): SkipWS not allowed in Whitespace symbol in line", ctx.current_filename, _ST_line_number));
        TNTSymbols(ctx, rule, is_whitespace, ruleCode, cutCode, ntCalls);
        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( ctx.add_line_directives )
                ruleCode = format("\n#line %d \"%s\"", _ST_line_number, ctx.current_filename);
            ruleCode ~= "\nremoveWS = true;\n"~ruleCode;
        }
        else if ( ctx.phase == SemanticPhase.generateGrammar )
            throw new SemanticException(format("%s(%d): SkipWS may only be used in LL parsers. Line %d", ctx.current_filename, _ST_line_number));
        break;
    case 45:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) QuotedString = &_ST_children[0]._S_QuotedString;
        void delegate(ref ParsingContext ctx, Rule rule, bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) OptTNTSymbols = &_ST_children[1]._S_OptTNTSymbols;

#line 195 "src/symbols.apd"

        string  msg;
        QuotedString(msg);

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( ctx.add_line_directives )
                cutCode = format("\n#line %d \"%s\"", _ST_line_number, ctx.current_filename);
            cutCode ~= "\nthrow new ParserException(format(\""~msg~"\",tmpLineNumber));\n";
        }
        else if ( ctx.phase == SemanticPhase.generateGrammar )
            rule.errorMessages[rule.symbols.length] = msg;

        string ignore;
        OptTNTSymbols(ctx, rule, is_whitespace, ruleCode, ignore, ntCalls);
        break;
    case 46:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, Rule rule, bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) OptTNTSymbols = &_ST_children[0]._S_OptTNTSymbols;

#line 213 "src/symbols.apd"

        if ( ctx.prop("parser_type") == "ll" )
            throw new SemanticException(format("%s(%d): !(sync) is used for LR parsers only", ctx.current_filename, _ST_line_number));
        if ( ctx.phase == SemanticPhase.generateGrammar )
            rule.syncs ~= rule.symbols.length;

        string ignore;
        OptTNTSymbols(ctx, rule, is_whitespace, ruleCode, ignore, ntCalls);
        break;
    case 47:
        debug assert(_ST_children.length == 2);
        void delegate(ref ParsingContext ctx, bool is_whitespace, out string escaped) StringTerminal = &_ST_children[0]._S_StringTerminal;
        void delegate(ref ParsingContext ctx, Rule rule, bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) OptTNTSymbols = &_ST_children[1]._S_OptTNTSymbols;

#line 224 "src/symbols.apd"

        string escaped_term;
        StringTerminal(ctx, is_whitespace, escaped_term);

        if ( ctx.phase == SemanticPhase.generateGrammar )
            rule.symbols ~= cast(Symbol)ctx.symbolFromLexeme(is_whitespace, escaped_term);

        string  nestedRuleCode,
                followingCutCode;
        OptTNTSymbols(ctx, rule, is_whitespace, nestedRuleCode, followingCutCode, ntCalls);

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( is_whitespace ) {
                ruleCode ~= "if ( readSymbol(false, tmpInput, tmpLineNumber) == "~.toString(ctx.symbolFromLexeme(is_whitespace, escaped_term))~" ) {\n";
                ruleCode ~= nestedRuleCode~followingCutCode~"\n}";
            }
            else
            {
                if ( ctx.add_line_directives )
                    ruleCode = format("\n#line %d \"%s\"", _ST_line_number, ctx.current_filename);
                ruleCode ~= "\nif ( readSymbol(removeWS, tmpInput, tmpLineNumber) == "~.toString(ctx.symbolFromLexeme(is_whitespace, escaped_term))~" ) {\n";
                ruleCode ~= nestedRuleCode~followingCutCode~"\n}";
            }
        }
        break;
    case 48:
        debug assert(_ST_children.length == 2);
        void delegate(out string ident, out string ntalias) NonTerminal = &_ST_children[0]._S_NonTerminal;
        void delegate(ref ParsingContext ctx, Rule rule, bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) OptTNTSymbols = &_ST_children[1]._S_OptTNTSymbols;

#line 252 "src/symbols.apd"

        string ntname, ntalias;
        NonTerminal(ntname, ntalias);

        if ( ctx.phase == SemanticPhase.generateGrammar || ctx.phase == SemanticPhase.generateLL )
        {
            auto nt = ctx.ntFromName(is_whitespace, ntname);
            if ( nt is null )
                throw new SemanticException(format("%s(%d): Unknown non-terminal %s", ctx.current_filename, _ST_line_number, ntname));
            if ( !is_whitespace && ("no_ast" in nt.attribs) is null ) {
                ntCalls ~= ntname;
                ntCalls ~= ntalias;
            }
        }

        if ( ctx.phase == SemanticPhase.generateGrammar )
        {
            if ( ctx.symbolFromNT(is_whitespace, ntname) == 0 )
                throw new SemanticException(format("%s(%d): Semantical error: undeclared non-terminal %s", ctx.current_filename, _ST_line_number, ntname));
            rule.symbols ~= ctx.symbolFromNT(is_whitespace, ntname);
        }

        string  nestedRuleCode,
                followingCutCode;
        OptTNTSymbols(ctx, rule, is_whitespace, nestedRuleCode, followingCutCode, ntCalls);

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            if ( ctx.add_line_directives )
                ruleCode = format("\n#line %d \"%s\"", _ST_line_number, ctx.current_filename);
            if ( !is_whitespace )
                ruleCode ~= "\nif ( _P_"~ntname~"(n, tmpInput, tmpLineNumber, removeWS) ) {\n "~nestedRuleCode~followingCutCode~"\n}";
            else
                ruleCode = "\nif ( "~ntname~"(tmpInput, tmpLineNumber) ) {\n "~nestedRuleCode~followingCutCode~"\n}";
        }
        break;

    default:
        assert(0);
    }
}
void _S_OptTNTSymbols(ref ParsingContext ctx, Rule rule, bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls)
{

    switch ( _ST_rule )
    {
    case 49:
        debug assert(_ST_children.length == 1);
        void delegate(ref ParsingContext ctx, Rule rule, in bool is_whitespace,
    out string ruleCode, out string cutCode, ref string[] ntCalls) TNTSymbols = &_ST_children[0]._S_TNTSymbols;

#line 294 "src/symbols.apd"
 TNTSymbols(ctx, rule, is_whitespace, ruleCode, cutCode, ntCalls);
        break;
    case 50:
        debug assert(_ST_children.length == 0);

#line 297 "src/symbols.apd"

        if ( ctx.phase == SemanticPhase.generateLL )
        {
            ruleCode = "input = tmpInput; lineNumber = tmpLineNumber;";
            if ( !is_whitespace )
                ruleCode ~= " node ~= n;";
            ruleCode ~= " return true;";
        }
        break;

    default:
        assert(0);
    }
}
void _S_NonTerminal(out string ident, out string ntalias)
{

    switch ( _ST_rule )
    {
    case 51:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;
        void delegate(out string value) Ident2 = &_ST_children[1]._S_Ident;

#line 311 "src/symbols.apd"

        Ident(ident);
        Ident2(ntalias);
        break;
    case 52:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;

#line 317 "src/symbols.apd"

        Ident(ident);
        ntalias = ident;
        break;

    default:
        assert(0);
    }
}
void _S_RegExp(out string value, out bool immediate)
{

    switch ( _ST_rule )
    {
    case 53:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) QuotedString = &_ST_children[0]._S_QuotedString;

#line 328 "src/symbols.apd"

        immediate = false;
        string tmp;
        QuotedString(tmp);

        bool escaped;
        foreach ( i, c; tmp )
        {
            if ( !escaped && c == '\\' ) {
                escaped = true;
                assert(i < tmp.length-1 && std.string.find("xuU", tmp[i+1]) < 0);
                continue;
            }
            escaped = false;
            value ~= c;
        }
        break;
    case 54:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) QuotedString = &_ST_children[0]._S_QuotedString;

#line 349 "src/symbols.apd"

        immediate = true;
        QuotedString(value);
        break;

    default:
        assert(0);
    }
}
void _S_RegExpTerminal(ref ParsingContext ctx, bool is_whitespace, out string regexp, out bool immediate)
{

    switch ( _ST_rule )
    {
    case 55:
        debug assert(_ST_children.length == 1);
        void delegate(out string value, out bool immediate) RegExp = &_ST_children[0]._S_RegExp;

#line 9 "src/basics.apd"

        RegExp(regexp, immediate);

        if ( ctx.phase == SemanticPhase.collectLexemes || ctx.phase == SemanticPhase.handleProlog || ctx.phase == SemanticPhase.doAll )
            ctx.addLexeme(is_whitespace, regexp, immediate);
        break;

    default:
        assert(0);
    }
}
void _S_StringTerminal(ref ParsingContext ctx, bool is_whitespace, out string escaped)
{

    switch ( _ST_rule )
    {
    case 56:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) QuotedString = &_ST_children[0]._S_QuotedString;

#line 20 "src/basics.apd"

        string term;
        QuotedString(term);
        foreach ( i, c; term )
        {
            if ( c == '\\' ) {
                assert(i < term.length-1 && std.string.find("xuU", term[i+1]) < 0);
                continue;
            }
            if ( std.string.find("[](){}^$*+?|.->", c) >= 0 )
                escaped ~= "\\"~c;
            else
                escaped ~= c;
        }

        if ( ctx.phase == SemanticPhase.collectLexemes )
            ctx.addLexeme(is_whitespace, escaped, false);
        break;

    default:
        assert(0);
    }
}
void _S_QuotedString(out string value)
{

    switch ( _ST_rule )
    {
    case 57:
        debug assert(_ST_children.length == 0);

#line 43 "src/basics.apd"
 value = _ST_match[1..$-1];
        break;

    default:
        assert(0);
    }
}
void _S_Ident(out string value)
{

    switch ( _ST_rule )
    {
    case 58:
        debug assert(_ST_children.length == 0);

#line 49 "src/basics.apd"
 value = _ST_match;
        break;

    default:
        assert(0);
    }
}
void _S_FQIdent(out string value)
{

    switch ( _ST_rule )
    {
    case 59:
        debug assert(_ST_children.length == 2);
        void delegate(out string value) FQIdent = &_ST_children[0]._S_FQIdent;
        void delegate(out string value) Ident = &_ST_children[1]._S_Ident;

#line 55 "src/basics.apd"

        FQIdent(value);
        string tmp;
        Ident(tmp);
        value ~= "."~tmp;
        break;
    case 60:
        debug assert(_ST_children.length == 1);
        void delegate(out string value) Ident = &_ST_children[0]._S_Ident;

#line 63 "src/basics.apd"
 Ident(value);
        break;

    default:
        assert(0);
    }
}
void _S_RuleBody(bool is_whitespace, bool add_line_directives, string filename, out string dcode, out bool has_code)
{

    switch ( _ST_rule )
    {
    case 61:
        debug assert(_ST_children.length == 0);
        break;
    case 62:
        debug assert(_ST_children.length == 1);
        void delegate(out string dcode, out bool has_code, in bool includeBrackets=true) DCodeBlock = &_ST_children[0]._S_DCodeBlock;

#line 71 "src/basics.apd"

        if ( is_whitespace )
            throw new SemanticException(format("%s(%d): Whitespace rules may not have bodies. Use ';' to terminale the rule", filename, _ST_line_number));
        DCodeBlock(dcode, has_code, false);
        if ( add_line_directives )
            dcode = format("\n#line %d \"%s\"\n%s", _ST_line_number, filename, dcode);
        break;

    default:
        assert(0);
    }
}
void _S_DCodeBlock(out string dcode, out bool has_code, in bool includeBrackets=true)
{

    switch ( _ST_rule )
    {
    case 63:
        debug assert(_ST_children.length == 3);
        void delegate() OpenCurly = &_ST_children[0]._S_OpenCurly;
        void delegate(out string dcode, out bool has_code) DCode = &_ST_children[1]._S_DCode;
        void delegate() CloseCurly = &_ST_children[2]._S_CloseCurly;

#line 83 "src/basics.apd"

        string dc;
        DCode(dc, has_code);
        if ( includeBrackets )
            dcode = _ST_children[0]._ST_match_ws~dc~_ST_children[2]._ST_match_ws;
        else
            dcode = dc;
        break;

    default:
        assert(0);
    }
}
void _S_OpenCurly()
{

    switch ( _ST_rule )
    {
    case 64:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_CloseCurly()
{

    switch ( _ST_rule )
    {
    case 65:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_DCode(out string dcode, out bool has_code)
{

    switch ( _ST_rule )
    {
    case 66:
        debug assert(_ST_children.length == 2);
        void delegate(out string dcode, out bool has_code) DCode = &_ST_children[0]._S_DCode;
        void delegate(out string dcode) DCodeSegment = &_ST_children[1]._S_DCodeSegment;

#line 106 "src/basics.apd"

        string dc1, dc2;
        DCode(dc1, has_code);
        DCodeSegment(dc2);
        dcode = dc1~dc2;
        has_code = true;
        break;
    case 67:
        debug assert(_ST_children.length == 0);
        break;

    default:
        assert(0);
    }
}
void _S_DCodeSegment(out string dcode)
{

    switch ( _ST_rule )
    {
    case 68:
        debug assert(_ST_children.length == 1);
        void delegate(out string dcode, out bool has_code, in bool includeBrackets=true) DCodeBlock = &_ST_children[0]._S_DCodeBlock;

#line 120 "src/basics.apd"

        bool tmp;
        DCodeBlock(dcode, tmp);
        break;
    case 69:
        debug assert(_ST_children.length == 0);

#line 126 "src/basics.apd"
 dcode = _ST_match_ws;
        break;

    default:
        assert(0);
    }
}

// generated code end
}

#line 1697 "src\parser.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.3 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

/**************************************************************************************************
    Lexer
**************************************************************************************************/

const string newlineString = "\n";

import std.utf;

// lexer code
// generated code start
// ((?[,\.\*/\+\-%$~\|&~'\\"0-9<\>\?:])|(?import)|(?;)|(?Properties)|(?\{)|(?\})|(?Lexemes)|(?Declaration)|(?=)|(?\()|(?\))|(?epsilon)|(?\[)|(?\])|(?\^)|(?KeepWS)|(?SkipWS)|(?!)|(?sync)|(?regexp)|(?regexpi)|(?"([^"\\]*(\\([^xuU]|(x[0-9a-fA-F]{2})|(u[0-9a-fA-F]{4})|(U[0-9a-fA-F]{8})))?)*")|(?[a-zA-Z_][a-zA-Z0-9_]*)|(?\.)).*?
bool mainLexer(string input, out uint token, out string match)
{
    uint s = 0;
    static int r48=-1, r49=-1, r50=-1, r51=-1, r52=-1, r53=-1, r54=-1, r55=-1, r56=-1, r57=-1, 
        r58=-1, r59=-1, r60=-1, r61=-1, r62=-1, r63=-1, r64=-1, r65=-1, r66=-1, r67=-1, 
        r68=-1, r69=-1, r70=-1, r71=-1, r72=-1, r73=-1, r74=-1, r75=-1, r76=-1, r77=-1, 
        r78=-1, r79=-1, r80=-1, r81=-1;

    for ( uint p = 0, q = 0, p_end = input.length; p < p_end; q = p )
    {
        auto c = decode(input, p);
        switch ( s )
        {
            case 0:
                if ( c == 0x44 ) {
                    s = 17;
                    r59 = p;
                }
                else if ( c == 0x7b ) {
                    s = 2;
                    r49 = p;
                }
                else if ( c == 0x50 ) {
                    s = 15;
                    r59 = p;
                }
                else if ( c == 0x4c ) {
                    s = 16;
                    r59 = p;
                }
                else if ( c == 0x65 ) {
                    s = 18;
                    r59 = p;
                }
                else if ( c == 0x3b ) {
                    s = 1;
                    r48 = p;
                }
                else if ( c == 0x4b ) {
                    s = 19;
                    r59 = p;
                }
                else if ( c == 0x53 ) {
                    s = 20;
                    r59 = p;
                }
                else if ( c == 0x73 ) {
                    s = 21;
                    r59 = p;
                }
                else if ( c == 0x69 ) {
                    s = 14;
                    r59 = p;
                }
                else if ( c == 0x2e ) {
                    s = 12;
                    r58 = p;
                }
                else if ( c == 0x22 ) {
                    s = 11;
                    r58 = p;
                }
                else if ( c == 0x72 ) {
                    s = 23;
                    r59 = p;
                }
                else if ( c == 0x7d ) {
                    s = 3;
                    r50 = p;
                }
                else if ( c == 0x3d ) {
                    s = 4;
                    r51 = p;
                }
                else if ( c == 0x28 ) {
                    s = 5;
                    r52 = p;
                }
                else if ( c == 0x29 ) {
                    s = 6;
                    r53 = p;
                }
                else if ( c == 0x5b ) {
                    s = 7;
                    r54 = p;
                }
                else if ( c == 0x5d ) {
                    s = 8;
                    r55 = p;
                }
                else if ( c == 0x5e ) {
                    s = 9;
                    r56 = p;
                }
                else if ( c == 0x21 ) {
                    s = 10;
                    r57 = p;
                }
                else if ( c >= 0x24 && c <= 0x27 || c >= 0x2a && c <= 0x2d || c >= 0x2f && c <= 0x3a || c == 0x3c || c >= 0x3e && c <= 0x3f || c == 0x5c || c == 0x7c || c == 0x7e ) {
                    s = 13;
                    r58 = p;
                }
                else if ( c >= 0x21 && c <= 0x22 || c >= 0x24 && c <= 0x3f || c >= 0x41 && c <= 0x5f || c >= 0x61 && c <= 0x7e ) {
                    s = 22;
                    r59 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 133;
                }
                else
                    goto finish1;
                break;
            case 2:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 132;
                }
                else
                    goto finish2;
                break;
            case 3:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 131;
                }
                else
                    goto finish3;
                break;
            case 4:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 130;
                }
                else
                    goto finish4;
                break;
            case 5:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 129;
                }
                else
                    goto finish5;
                break;
            case 6:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 128;
                }
                else
                    goto finish6;
                break;
            case 7:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 127;
                }
                else
                    goto finish7;
                break;
            case 8:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 126;
                }
                else
                    goto finish8;
                break;
            case 9:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 125;
                }
                else
                    goto finish9;
                break;
            case 10:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 124;
                }
                else
                    goto finish10;
                break;
            case 11:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish11;
                break;
            case 12:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish12;
                break;
            case 13:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish13;
                break;
            case 14:
                if ( c == 0x6d ) {
                    s = 94;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish14;
                break;
            case 15:
                if ( c == 0x72 ) {
                    s = 83;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish15;
                break;
            case 16:
                if ( c == 0x65 ) {
                    s = 75;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish16;
                break;
            case 17:
                if ( c == 0x65 ) {
                    s = 63;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish17;
                break;
            case 18:
                if ( c == 0x70 ) {
                    s = 55;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish18;
                break;
            case 19:
                if ( c == 0x65 ) {
                    s = 48;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish19;
                break;
            case 20:
                if ( c == 0x6b ) {
                    s = 41;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish20;
                break;
            case 21:
                if ( c == 0x79 ) {
                    s = 36;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish21;
                break;
            case 22:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish22;
                break;
            case 23:
                if ( c == 0x65 ) {
                    s = 25;
                    r61 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                }
                else
                    goto finish23;
                break;
            case 24:
                goto finish24;
            case 25:
                if ( c == 0x67 ) {
                    s = 27;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish25;
                break;
            case 26:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish26;
                break;
            case 27:
                if ( c == 0x65 ) {
                    s = 28;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish27;
                break;
            case 28:
                if ( c == 0x78 ) {
                    s = 29;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish28;
                break;
            case 29:
                if ( c == 0x70 ) {
                    s = 30;
                    r65 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish29;
                break;
            case 30:
                if ( c == 0x69 ) {
                    s = 32;
                    r67 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 31;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 33;
                }
                else
                    goto finish30;
                break;
            case 31:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish31;
                break;
            case 32:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 35;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 34;
                }
                else
                    goto finish32;
                break;
            case 33:
                goto finish33;
            case 34:
                goto finish34;
            case 35:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r68;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r68;
                }
                else
                    goto finish35;
                break;
            case 36:
                if ( c == 0x6e ) {
                    s = 37;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish36;
                break;
            case 37:
                if ( c == 0x63 ) {
                    s = 38;
                    r69 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish37;
                break;
            case 38:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 40;
                    r64 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 39;
                }
                else
                    goto finish38;
                break;
            case 39:
                goto finish39;
            case 40:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish40;
                break;
            case 41:
                if ( c == 0x69 ) {
                    s = 42;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish41;
                break;
            case 42:
                if ( c == 0x70 ) {
                    s = 43;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish42;
                break;
            case 43:
                if ( c == 0x57 ) {
                    s = 44;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish43;
                break;
            case 44:
                if ( c == 0x53 ) {
                    s = 45;
                    r70 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish44;
                break;
            case 45:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 47;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 46;
                }
                else
                    goto finish45;
                break;
            case 46:
                goto finish46;
            case 47:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish47;
                break;
            case 48:
                if ( c == 0x65 ) {
                    s = 49;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish48;
                break;
            case 49:
                if ( c == 0x70 ) {
                    s = 50;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish49;
                break;
            case 50:
                if ( c == 0x57 ) {
                    s = 51;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish50;
                break;
            case 51:
                if ( c == 0x53 ) {
                    s = 52;
                    r71 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish51;
                break;
            case 52:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 54;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 53;
                }
                else
                    goto finish52;
                break;
            case 53:
                goto finish53;
            case 54:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish54;
                break;
            case 55:
                if ( c == 0x73 ) {
                    s = 56;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish55;
                break;
            case 56:
                if ( c == 0x69 ) {
                    s = 57;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish56;
                break;
            case 57:
                if ( c == 0x6c ) {
                    s = 58;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish57;
                break;
            case 58:
                if ( c == 0x6f ) {
                    s = 59;
                    r72 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish58;
                break;
            case 59:
                if ( c == 0x6e ) {
                    s = 60;
                    r73 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r72;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r72;
                }
                else
                    goto finish59;
                break;
            case 60:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 62;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 61;
                }
                else
                    goto finish60;
                break;
            case 61:
                goto finish61;
            case 62:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r68;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r68;
                }
                else
                    goto finish62;
                break;
            case 63:
                if ( c == 0x63 ) {
                    s = 64;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish63;
                break;
            case 64:
                if ( c == 0x6c ) {
                    s = 65;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish64;
                break;
            case 65:
                if ( c == 0x61 ) {
                    s = 66;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish65;
                break;
            case 66:
                if ( c == 0x72 ) {
                    s = 67;
                    r72 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish66;
                break;
            case 67:
                if ( c == 0x61 ) {
                    s = 68;
                    r66 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r72;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r72;
                }
                else
                    goto finish67;
                break;
            case 68:
                if ( c == 0x74 ) {
                    s = 69;
                    r68 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish68;
                break;
            case 69:
                if ( c == 0x69 ) {
                    s = 70;
                    r74 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r68;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r68;
                }
                else
                    goto finish69;
                break;
            case 70:
                if ( c == 0x6f ) {
                    s = 71;
                    r75 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r74;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r74;
                }
                else
                    goto finish70;
                break;
            case 71:
                if ( c == 0x6e ) {
                    s = 72;
                    r76 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r75;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r75;
                }
                else
                    goto finish71;
                break;
            case 72:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 74;
                    r77 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 73;
                }
                else
                    goto finish72;
                break;
            case 73:
                goto finish73;
            case 74:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r77;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r77;
                }
                else
                    goto finish74;
                break;
            case 75:
                if ( c == 0x78 ) {
                    s = 76;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish75;
                break;
            case 76:
                if ( c == 0x65 ) {
                    s = 77;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish76;
                break;
            case 77:
                if ( c == 0x6d ) {
                    s = 78;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish77;
                break;
            case 78:
                if ( c == 0x65 ) {
                    s = 79;
                    r72 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish78;
                break;
            case 79:
                if ( c == 0x73 ) {
                    s = 80;
                    r78 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r72;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r72;
                }
                else
                    goto finish79;
                break;
            case 80:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 82;
                    r68 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 81;
                }
                else
                    goto finish80;
                break;
            case 81:
                goto finish81;
            case 82:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r68;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r68;
                }
                else
                    goto finish82;
                break;
            case 83:
                if ( c == 0x6f ) {
                    s = 84;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish83;
                break;
            case 84:
                if ( c == 0x70 ) {
                    s = 85;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish84;
                break;
            case 85:
                if ( c == 0x65 ) {
                    s = 86;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish85;
                break;
            case 86:
                if ( c == 0x72 ) {
                    s = 87;
                    r72 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish86;
                break;
            case 87:
                if ( c == 0x74 ) {
                    s = 88;
                    r66 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r72;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r72;
                }
                else
                    goto finish87;
                break;
            case 88:
                if ( c == 0x69 ) {
                    s = 89;
                    r68 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish88;
                break;
            case 89:
                if ( c == 0x65 ) {
                    s = 90;
                    r74 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r68;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r68;
                }
                else
                    goto finish89;
                break;
            case 90:
                if ( c == 0x73 ) {
                    s = 91;
                    r79 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r74;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r74;
                }
                else
                    goto finish90;
                break;
            case 91:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 93;
                    r80 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 92;
                }
                else
                    goto finish91;
                break;
            case 92:
                goto finish92;
            case 93:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r80;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r80;
                }
                else
                    goto finish93;
                break;
            case 94:
                if ( c == 0x70 ) {
                    s = 95;
                    r62 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r61;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r61;
                }
                else
                    goto finish94;
                break;
            case 95:
                if ( c == 0x6f ) {
                    s = 96;
                    r63 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r62;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r62;
                }
                else
                    goto finish95;
                break;
            case 96:
                if ( c == 0x72 ) {
                    s = 97;
                    r64 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r63;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r63;
                }
                else
                    goto finish96;
                break;
            case 97:
                if ( c == 0x74 ) {
                    s = 98;
                    r81 = p;
                }
                else if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r64;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r64;
                }
                else
                    goto finish97;
                break;
            case 98:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 100;
                    r66 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 99;
                }
                else
                    goto finish98;
                break;
            case 99:
                goto finish99;
            case 100:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5a || c == 0x5f || c >= 0x61 && c <= 0x7a ) {
                    s = 26;
                    r61 = p;
                    r59 = r66;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 24;
                    r59 = r66;
                }
                else
                    goto finish100;
                break;
            case 101:
                goto finish101;
            case 102:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish102;
                break;
            case 103:
                if ( c == 0x78 ) {
                    s = 106;
                }
                else if ( c == 0x75 ) {
                    s = 107;
                }
                else if ( c == 0x55 ) {
                    s = 108;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 109;
                }
                else
                    goto finish103;
                break;
            case 104:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 105;
                }
                else
                    goto finish104;
                break;
            case 105:
                goto finish105;
            case 106:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 122;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish106;
                break;
            case 107:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 118;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish107;
                break;
            case 108:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 110;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish108;
                break;
            case 109:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish109;
                break;
            case 110:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 111;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish110;
                break;
            case 111:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 112;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish111;
                break;
            case 112:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 113;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish112;
                break;
            case 113:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 114;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish113;
                break;
            case 114:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 115;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish114;
                break;
            case 115:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 116;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish115;
                break;
            case 116:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 117;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish116;
                break;
            case 117:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish117;
                break;
            case 118:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 119;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish118;
                break;
            case 119:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 120;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish119;
                break;
            case 120:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 121;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish120;
                break;
            case 121:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish121;
                break;
            case 122:
                if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66 ) {
                    s = 123;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 101;
                }
                else
                    goto finish122;
                break;
            case 123:
                if ( c == 0x5c ) {
                    s = 103;
                }
                else if ( c == 0x22 ) {
                    s = 104;
                    r60 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 102;
                }
                else
                    goto finish123;
                break;
            case 124:
                goto finish124;
            case 125:
                goto finish125;
            case 126:
                goto finish126;
            case 127:
                goto finish127;
            case 128:
                goto finish128;
            case 129:
                goto finish129;
            case 130:
                goto finish130;
            case 131:
                goto finish131;
            case 132:
                goto finish132;
            case 133:
                goto finish133;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 1: finish1:
        case 133: finish133:
            match = input[0 .. r48];
            token = 2;
            break;
        case 98: finish98:
        case 99: finish99:
            match = input[0 .. r81];
            token = 1;
            break;
        case 2: finish2:
        case 132: finish132:
            match = input[0 .. r49];
            token = 4;
            break;
        case 3: finish3:
        case 131: finish131:
            match = input[0 .. r50];
            token = 5;
            break;
        case 4: finish4:
        case 130: finish130:
            match = input[0 .. r51];
            token = 8;
            break;
        case 5: finish5:
        case 129: finish129:
            match = input[0 .. r52];
            token = 9;
            break;
        case 6: finish6:
        case 128: finish128:
            match = input[0 .. r53];
            token = 10;
            break;
        case 7: finish7:
        case 127: finish127:
            match = input[0 .. r54];
            token = 12;
            break;
        case 104: finish104:
        case 105: finish105:
            match = input[0 .. r60];
            token = 21;
            break;
        case 8: finish8:
        case 126: finish126:
            match = input[0 .. r55];
            token = 13;
            break;
        case 9: finish9:
        case 125: finish125:
            match = input[0 .. r56];
            token = 14;
            break;
        case 10: finish10:
        case 124: finish124:
            match = input[0 .. r57];
            token = 17;
            break;
        case 11: finish11:
        case 12: finish12:
        case 13: finish13:
        case 101: finish101:
        case 102: finish102:
        case 103: finish103:
        case 106: finish106:
        case 107: finish107:
        case 108: finish108:
        case 109: finish109:
        case 110: finish110:
        case 111: finish111:
        case 112: finish112:
        case 113: finish113:
        case 114: finish114:
        case 115: finish115:
        case 116: finish116:
        case 117: finish117:
        case 118: finish118:
        case 119: finish119:
        case 120: finish120:
        case 121: finish121:
        case 122: finish122:
        case 123: finish123:
            match = input[0 .. r58];
            token = 0;
            break;
        case 14: finish14:
        case 15: finish15:
        case 16: finish16:
        case 17: finish17:
        case 18: finish18:
        case 19: finish19:
        case 20: finish20:
        case 21: finish21:
        case 22: finish22:
        case 23: finish23:
        case 24: finish24:
            match = input[0 .. r59];
            token = 22;
            break;
        case 25: finish25:
        case 26: finish26:
        case 36: finish36:
        case 41: finish41:
        case 48: finish48:
        case 55: finish55:
        case 63: finish63:
        case 75: finish75:
        case 83: finish83:
        case 94: finish94:
            match = input[0 .. r61];
            token = 22;
            break;
        case 27: finish27:
        case 37: finish37:
        case 42: finish42:
        case 49: finish49:
        case 56: finish56:
        case 64: finish64:
        case 76: finish76:
        case 84: finish84:
        case 95: finish95:
            match = input[0 .. r62];
            token = 22;
            break;
        case 28: finish28:
        case 43: finish43:
        case 50: finish50:
        case 57: finish57:
        case 65: finish65:
        case 77: finish77:
        case 85: finish85:
        case 96: finish96:
            match = input[0 .. r63];
            token = 22;
            break;
        case 29: finish29:
        case 40: finish40:
        case 44: finish44:
        case 51: finish51:
        case 58: finish58:
        case 66: finish66:
        case 78: finish78:
        case 86: finish86:
        case 97: finish97:
            match = input[0 .. r64];
            token = 22;
            break;
        case 30: finish30:
        case 33: finish33:
            match = input[0 .. r65];
            token = 19;
            break;
        case 31: finish31:
        case 47: finish47:
        case 54: finish54:
        case 68: finish68:
        case 88: finish88:
        case 100: finish100:
            match = input[0 .. r66];
            token = 22;
            break;
        case 32: finish32:
        case 34: finish34:
            match = input[0 .. r67];
            token = 20;
            break;
        case 35: finish35:
        case 62: finish62:
        case 69: finish69:
        case 82: finish82:
        case 89: finish89:
            match = input[0 .. r68];
            token = 22;
            break;
        case 38: finish38:
        case 39: finish39:
            match = input[0 .. r69];
            token = 18;
            break;
        case 45: finish45:
        case 46: finish46:
            match = input[0 .. r70];
            token = 16;
            break;
        case 52: finish52:
        case 53: finish53:
            match = input[0 .. r71];
            token = 15;
            break;
        case 59: finish59:
        case 67: finish67:
        case 79: finish79:
        case 87: finish87:
            match = input[0 .. r72];
            token = 22;
            break;
        case 60: finish60:
        case 61: finish61:
            match = input[0 .. r73];
            token = 11;
            break;
        case 70: finish70:
        case 90: finish90:
            match = input[0 .. r74];
            token = 22;
            break;
        case 71: finish71:
            match = input[0 .. r75];
            token = 22;
            break;
        case 72: finish72:
        case 73: finish73:
            match = input[0 .. r76];
            token = 7;
            break;
        case 74: finish74:
            match = input[0 .. r77];
            token = 22;
            break;
        case 80: finish80:
        case 81: finish81:
            match = input[0 .. r78];
            token = 6;
            break;
        case 91: finish91:
        case 92: finish92:
            match = input[0 .. r79];
            token = 3;
            break;
        case 93: finish93:
            match = input[0 .. r80];
            token = 22;
            break;
        default:
            return false;
    }
    return true;
}
// ((?/\*([^\*]|\*>/)*\*/)|(?//[^\n]*\n)|(?[\n\r\t ]+)).*?
bool wsLexer(string input, out uint token, out string match)
{
    uint s = 0;
    static int r6=-1, r7=-1, r8=-1, r9=-1;

    for ( uint p = 0, q = 0, p_end = input.length; p < p_end; q = p )
    {
        auto c = decode(input, p);
        switch ( s )
        {
            case 0:
                if ( c == 0x2f ) {
                    s = 2;
                }
                else if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 1;
                    r6 = p;
                }
                else
                    return false;
                break;
            case 1:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 13;
                    r7 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 12;
                }
                else
                    goto finish1;
                break;
            case 2:
                if ( c == 0x2a ) {
                    s = 3;
                }
                else if ( c == 0x2f ) {
                    s = 4;
                }
                else
                    return false;
                break;
            case 3:
                if ( c == 0x2a ) {
                    s = 9;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 8;
                }
                else
                    return false;
                break;
            case 4:
                if ( c == 0xa ) {
                    s = 6;
                    r8 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 5;
                }
                else
                    return false;
                break;
            case 5:
                if ( c == 0xa ) {
                    s = 6;
                    r8 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 5;
                }
                else
                    return false;
                break;
            case 6:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 7;
                }
                else
                    goto finish6;
                break;
            case 7:
                goto finish7;
            case 8:
                if ( c == 0x2a ) {
                    s = 9;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 8;
                }
                else
                    return false;
                break;
            case 9:
                if ( c == 0x2f ) {
                    s = 10;
                    r9 = p;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 8;
                    p = q;
                }
                else
                    return false;
                break;
            case 10:
                if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 11;
                }
                else
                    goto finish10;
                break;
            case 11:
                goto finish11;
            case 12:
                goto finish12;
            case 13:
                if ( c >= 0x9 && c <= 0xa || c == 0xd || c == 0x20 ) {
                    s = 13;
                    r7 = p;
                    r6 = r7;
                }
                else if ( c >= 0x9 && c <= 0x13 || c >= 0x20 && c <= 0x7e || c >= 0xa0 && c <= 0x24f || c >= 0x20a3 && c <= 0x20b5 ) {
                    s = 12;
                    r6 = r7;
                }
                else
                    goto finish13;
                break;
            default:
                assert(0);
        }
    }

    switch ( s )
    {
        case 1: finish1:
        case 12: finish12:
            match = input[0 .. r6];
            token = 2;
            break;
        case 6: finish6:
        case 7: finish7:
            match = input[0 .. r8];
            token = 1;
            break;
        case 10: finish10:
        case 11: finish11:
            match = input[0 .. r9];
            token = 0;
            break;
        case 13: finish13:
            match = input[0 .. r7];
            token = 2;
            break;
        default:
            return false;
    }
    return true;
}
// generated code end

#line 3788 "src\parser.d"
// Written in the D programming language

/*
 *  This file has been automatically generated by APaGeD v0.3 beta - Attributed Parser Generator for D.
 *
 *  Sections generated from custom input are marked as "generated code" and
 *  are subject to the terms and conditions stated in one of these sections.
 *  The remaining sections are part of the APaGeD package and subject
 *  to the terms and conditions of the corresponding license.
 *
 *  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0
 */

import std.string;
debug import std.stdio;



/**************************************************************************************************
    Parser
**************************************************************************************************/

typedef uint Token;
alias Token Symbol;

const Token     EPSILON         = 1,
                ALTERN          = 2,
                EOS             = 3,
                FIRST_TOKEN     = 4,
                FIRST_NT        = 0x1000;

// generated code start
/*  Attributed Parser Generator for D
 *  Copyright (c) 2007 Jascha Wetzel. All rights reserved
 *  License: Artistic License 2.0, see license.txt
 */

const uint  MAX_INPUT_DUMP = 70,
            LR_STACK_RESERVE = 100,
            NODE_STACK_RESERVE = 20;

/*******************************************************************************
    Stack based on dynamic array
*******************************************************************************/
struct Stack(T)
{
    size_t  _top;
    T[]     stack;

    void push(T v)
    {
        if ( _top >= stack.length )
            stack.length = stack.length*2+1;
        stack[_top] = v;
        ++_top;
    }

    void push(T[] vs)
    {
        size_t end = _top+vs.length;
        if ( end > stack.length )
            stack.length = end*2;
        stack[_top..end] = vs;
        _top = end;
    }
    alias push opCatAssign;

    void pop(size_t num)
    {
        assert(_top>=num);
        if ( num >= _top )
            _top = 0;
        else
            _top -= num;
    }

    T pop()
    {
        assert(_top>0);
        return stack[--_top];
    }

    T top()
    {
        assert(_top>0);
        return stack[_top-1];
    }

    bool empty()
    {
        return _top == 0;
    }

    void clear()
    {
        _top = 0;
    }

    size_t length()
    {
        return _top;
    }

    T[] array()
    {
        return stack[0.._top];
    }

    Stack dup()
    {
        Stack s;
        s._top = _top;
        s.stack = stack.dup;
        return s;
    }
}

/**************************************************************************************************
    Information about rules needed for reduction and error handling
**************************************************************************************************/
align(1) struct RuleInfo
{
    bool    ast_node;
    uint    symbol_count,
            nt_count,
            nt_index;
    Symbol[]  symbols;
}

/**************************************************************************************************
    Information about LALR(1) entries needed for debugging
**************************************************************************************************/
align(1) struct EntryInfo
{
    uint    rule_index,
            pos;
}

/**************************************************************************************************
    Exception thrown on parser error
**************************************************************************************************/
class ParserException : Exception
{
    uint    line_number;
    string  filename,
            error_message,
            detail;

    this(uint line, string fname, string msg, string dtl="detail")
    {
        super(format("%s(%d): %s%s", fname, line, msg, dtl !is null?"\n"~dtl:""));
        filename = fname;
        error_message = msg;
        line_number = line;
        detail = dtl;
    }
}

/**************************************************************************************************
    Wraps instantiation of the GLR parser class and the parse call.
**************************************************************************************************/
bool parse(string filename, string input, out SyntaxTree* root, bool detailed=false, bool recover=false)
{
    GLRParser   g, w;
    static if ( is(typeof(WhitespaceGrammar) : GLRParser) )
        w = new WhitespaceGrammar;
    g = new MainGrammar(w);
    bool succ = g.parse(filename, input, &root, detailed, recover);
    debug(parser) writefln("\n%d branches", g.branches);
    return succ;
}

/**************************************************************************************************
    GLR parser
**************************************************************************************************/
abstract class GLRParser
{
    struct LRState
    {
        uint    index,
                line_number;
    }
    
    struct Node
    {
        SyntaxTree* node;
        bool        sync;
    }

    string          filename;
    
    // operational variables
    string          match,
                    match_ws,
                    lookahead,
                    lookahead_ws;
    SyntaxTree*     syntax_root;
    Stack!(LRState) stack;
    Stack!(Node)    node_stack;
    ParserException[]   recovered_errors;
    bool            recover_from_errors,
                    detailed_errors;

    uint            branches;

    // grammar data
    GLRParser       ws_parser;
    uint            first_nt;
    RuleInfo[]      rule_infos;
    string[][]      error_message_lists;
    string[]        nt_names,
                    lexeme_names;
    EntryInfo[][]   entry_infos;

    this(GLRParser ws=null)
    {
        ws_parser = ws;
        stack.stack.length = LR_STACK_RESERVE;
        node_stack.stack.length = NODE_STACK_RESERVE;
    }

    /**************************************************************************************************
        Gets overridden with a first-longest-match lexical analizer.
    **************************************************************************************************/
    bool function(string, out uint, out string) lexer;

    /**************************************************************************************************
        Gets overridden with the main parser function.
    **************************************************************************************************/
    bool parse(ref string, uint, uint, bool);

    /**************************************************************************************************

    **************************************************************************************************/
    T APDmin(T)(T a, T b) { return a<b?a:b; }
    uint[] lookaheadForNT(uint nt_index, uint state);

    /**************************************************************************************************
        Initiates the parse call.
    **************************************************************************************************/
    bool parse(string fname, ref string input, SyntaxTree** root=null, bool detailed=false, bool recover=false)
    {
        filename = fname;
        recover_from_errors = recover;
        detailed_errors = detailed;

        stack.clear;
        node_stack.clear;
        stack ~= LRState(0,1);
        if ( parse(input, 1, 0, true) )
        {
            if ( syntax_root !is null && root !is null )
            {
                *root = syntax_root;
                debug
                {
                    Stack!(SyntaxTree*) st;
                    st.push(*root);
                    while ( !st.empty )
                    {
                        SyntaxTree* pn = st.pop;
                        foreach ( c; pn._ST_children ) {
                            c.parent = pn;
                            st.push(c);
                        }
                    }
                }
            }
            return true;
        }
        return false;
    }

    /**************************************************************************************************
        Read lexemes from the input.
        Skips whitespace, if the parser has an embedded whitespace grammar.
        Then searches for first-longest-match using TDFA lexer.
        Advances line_number.
    **************************************************************************************************/
    Token readSymbol(ref string input, ref uint line_number, uint state)
    {
        string tmp_input = input;
        uint ws_length;
        if ( ws_parser !is null ) {
            ws_parser.parse(filename, input);
            ws_length = tmp_input.length-input.length;
            debug(lexer) writefln("WS: '%s'", tmp_input[0..ws_length]);
        }

        if ( input.length == 0 ) {
            lookahead = null;
            lookahead_ws = tmp_input;
            return EOS;
        }

        uint token;
        if ( lexer(input, token, lookahead) ) {
            token += FIRST_TOKEN;
            lookahead_ws = tmp_input[0..ws_length+lookahead.length];
            line_number += count(lookahead_ws, newlineString);
        }

        return cast(Token)token;
    }

    /**************************************************************************************************
        Create a node for the syntax tree. Used by the main parse function.
    **************************************************************************************************/
    void createNode(uint line_number, uint rule_index, uint nt_count)
    {
        SyntaxTree* pn = new SyntaxTree;
        pn._ST_rule = rule_index;
        pn._ST_line_number = line_number;

        if ( nt_count > 0 )
        {
            foreach ( n; node_stack.array[$-nt_count .. $] )
                pn._ST_children ~= n.node;
            node_stack.pop(nt_count);
        }
        else {
            pn._ST_match = match;
            pn._ST_match_ws = match_ws;
        }
        node_stack ~= Node(pn, false);
    }

    debug void createNode(uint line_number, uint rule_index, uint nt_count, uint nt_index)
    {
        SyntaxTree* pn = new SyntaxTree;
        pn._ST_rule = rule_index;
        pn._ST_line_number = line_number;
        pn._ST_node_name = nt_names[nt_index];

        if ( nt_count > 0 )
        {
            foreach ( n; node_stack.array[$-nt_count .. $] )
                pn._ST_children ~= n.node;
            node_stack.pop(nt_count);
        }
        else {
            pn._ST_match = match;
            pn._ST_match_ws = match_ws;
        }
        node_stack ~= Node(pn, false);
    }

    /**************************************************************************************************
        Issue an error. Used by the main parse function.
    **************************************************************************************************/
    void error(string input, uint line_number, uint error_list, uint symbol, bool fatal=true)
    {
        // collect explicit error messages
        string errors;
        foreach ( i, err; error_message_lists[error_list] )
        {
            if ( i > 0 )
                errors ~= "\n";
            errors ~= err;
        }

        // construct automatic error message
        // if no explicit error message available
        if ( errors.length == 0 )
        {
            bool[string] expected_symbols;
            EntryInfo[] eis = entry_infos[stack.top.index];
            foreach ( ei; eis )
            {
                RuleInfo* ri = &rule_infos[ei.rule_index];
                if ( ei.pos < ri.symbols.length )
                {
                    auto s = ri.symbols[ei.pos];
                    if ( s < FIRST_NT )
                        expected_symbols["\""~lexeme_names[s-EOS]~"\""] = true;
                    else
                        expected_symbols[nt_names[s-FIRST_NT]] = true;
                }
                else
                {
                    foreach ( token; lookaheadForNT(ri.nt_index, stack.top.index) ) {
                        assert(token < FIRST_NT);
                        expected_symbols["\""~lexeme_names[token-EOS]~"\""] = true;
                    }
                }
            }

            string expected_str;
            auto last = expected_symbols.length-1;
            foreach ( i, symname; expected_symbols.keys )
            {
                if ( i > 0 )
                {
                    if ( i == last )
                        expected_str ~= " or ";
                    else 
                        expected_str ~= ", ";
                }
                expected_str ~= symname;
            }
            errors = format("found \"%s\", expected %s", lookahead, expected_str);
        }

        // construct detail message
        string detail;
        if ( detailed_errors )
        {
            string          lr_stack;
            foreach ( st; stack.array[1..$] )
            {
                lr_stack ~= format("---- State %d (%d) ----\n", st.index, st.line_number);
                EntryInfo[] eis = entry_infos[st.index];
                foreach ( ei; eis )
                {
                    RuleInfo* ri = &rule_infos[ei.rule_index];
                    lr_stack ~= format("%s ->", nt_names[ri.nt_index]);
                    
                    foreach ( i, s; ri.symbols )
                    {
                        string name;
                        if ( s < FIRST_NT )
                            name = lexeme_names[s-EOS];
                        else
                            name = nt_names[s-FIRST_NT];
                        if ( i == ei.pos )
                            lr_stack ~= " .";
                        lr_stack ~= format(" %s", name);
                    }
                    if ( ei.pos == ri.symbols.length )
                        lr_stack ~= " .";
                    lr_stack ~= "\n";
                }
            }
            
            string node_stack_str;
            foreach ( i, n; node_stack.array )
            {
                if ( i > 0 )
                    node_stack_str ~= " ";
                node_stack_str ~= nt_names[rule_infos[n.node._ST_rule].nt_index];
                if ( n.sync )
                    node_stack_str ~= "*";
            }

            detail = format("input: %s\nlookahead: %s\nlexeme: %s\nAST node stack:\n%s\nLR stack:\n%s",
                replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n"),
                lookahead, lexeme_names[symbol-EOS],
                node_stack_str, lr_stack
            );
        }

        // throw error
        if ( fatal )
            throw new ParserException(line_number, filename, errors, detail);
        else
            debug(nonfatal) writefln("\n%s(%d): %s\n%s", filename, line_number, errors, detail);
    }
}

/**************************************************************************************************
    Generated parsers
**************************************************************************************************/
class MainGrammar : GLRParser
{
    const ushort[]  action_base =
    [
        0,0,7,1,16,3,7,39,5,13,0,6,12,46,36,3,22,60,45,49,50,8,64,87,14,6,109,112,117,141,27,9,163,
        116,167,170,173,193,180,47,216,239,262,286,310,334,358,382,406,1,431,116,65,456,52,481,55,
        229,106,506,183,175,234,238,517,520,527,530,51,45,68,551,203,530,554,555,575,558,578,602,
        624,102,627,559,579,583,111,532,642,114,666,685,698,711,628,631,129,566,734,758,156,630,
        166,628,633,634,689,782,806,830,699,855
    ];
    const ubyte[]  action_check =
    [
        1,49,0,112,0,10,5,0,0,2,6,2,15,21,2,2,9,25,12,4,31,4,4,0,3,4,4,5,8,11,2,6,4,4,4,12,24,9,4,4,
        4,7,14,7,16,16,7,7,13,30,13,18,39,13,13,19,20,54,56,14,56,68,7,17,69,17,17,69,18,13,52,17,
        19,20,17,52,17,17,17,70,17,17,17,17,22,22,22,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
        23,23,23,23,23,23,23,23,23,23,26,81,26,26,51,86,27,28,89,28,33,26,28,28,58,58,58,26,26,26,
        27,27,27,96,33,33,33,51,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
        29,29,29,29,32,100,32,32,34,102,34,34,112,112,35,32,61,36,61,34,112,32,32,32,38,34,34,34,
        35,35,35,36,36,36,37,60,37,37,38,38,38,60,60,60,72,37,72,37,37,37,112,37,37,37,37,40,40,40,
        40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,41,112,41,57,112,41,41,62,
        57,57,57,63,112,62,62,62,112,63,63,63,112,41,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,
        42,42,42,42,42,42,42,42,42,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,
        43,43,43,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,44,45,45,45,
        45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,45,46,46,46,46,46,46,46,46,46,
        46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,
        47,47,47,47,47,47,47,47,47,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
        48,48,48,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,53,53,
        53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,53,55,55,55,55,55,55,55,
        55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,55,59,59,59,59,59,59,59,59,59,59,59,59,
        59,59,59,59,59,59,59,59,59,59,59,59,59,64,87,73,65,73,112,64,64,64,65,65,65,66,66,66,67,67,
        67,66,66,112,67,67,71,87,71,74,75,74,75,77,83,77,83,112,97,71,71,71,74,74,74,71,71,112,74,
        74,76,112,76,78,84,78,84,112,85,78,85,97,112,76,76,76,78,78,78,76,76,112,78,78,79,79,79,79,
        79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,79,80,103,80,82,94,82,94,95,
        101,95,112,104,105,80,80,80,82,82,82,80,80,88,82,82,103,112,101,88,88,104,105,88,88,88,112,
        88,88,88,88,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,91,
        112,112,106,112,112,91,91,110,112,91,91,91,92,91,91,91,91,112,92,92,106,112,92,92,92,93,92,
        92,92,92,110,93,93,112,112,93,93,93,112,93,93,93,93,98,98,98,98,98,98,98,98,98,98,98,98,98,
        98,98,98,98,98,98,98,98,98,98,98,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
        99,99,99,99,99,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,
        107,107,107,107,107,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,
        108,108,108,108,108,108,108,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,
        109,109,109,109,109,109,109,109,109,111,112,112,112,112,112,112,112,112,112,112,112,112,
        112,112,112,112,112,112,112,112,112,112,111
    ];
    const ushort[]  action_data =
    [
        0,256,261,384,261,139,316,261,261,131,135,138,144,150,149,167,315,154,141,314,160,314,314,
        261,132,314,314,316,132,132,132,136,314,314,314,132,145,315,314,314,314,257,266,257,145,
        132,257,257,258,145,258,269,168,258,258,268,267,168,293,266,293,197,257,313,198,313,313,
        145,269,258,181,313,268,267,313,226,313,313,313,199,313,313,313,313,151,157,145,385,385,
        385,385,385,385,385,385,385,385,152,385,385,385,385,385,385,385,385,385,385,385,385,385,
        385,309,210,309,309,271,215,156,259,286,259,262,309,259,259,297,297,297,309,309,309,151,
        157,145,225,262,262,262,271,259,385,385,385,385,385,385,385,385,385,385,158,385,385,385,
        385,385,385,385,385,385,385,385,385,385,385,310,229,310,310,311,181,311,311,384,384,265,
        310,295,264,295,311,384,310,310,310,263,311,311,311,265,265,265,264,264,264,312,189,312,
        312,263,263,263,151,157,145,305,312,305,312,312,312,384,312,312,312,312,320,320,320,320,
        320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,320,260,384,
        260,186,384,260,260,289,298,298,298,291,384,289,289,289,384,291,291,291,384,260,323,323,
        323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,323,
        172,172,172,172,168,173,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,
        172,172,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,325,
        325,325,325,325,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,321,
        321,321,321,321,321,321,324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,324,
        324,324,324,324,324,324,324,324,319,319,319,319,319,319,319,319,319,319,319,319,319,319,
        319,319,319,319,319,319,319,319,319,319,322,322,322,322,322,322,322,322,322,322,322,322,
        322,322,322,322,322,322,322,322,322,322,322,322,270,386,386,386,386,386,386,386,386,386,
        386,386,386,386,386,386,386,386,386,386,386,386,386,132,386,387,387,387,387,387,387,287,
        387,182,387,387,387,184,185,387,387,194,195,196,387,151,157,145,132,387,388,388,388,388,
        388,388,287,388,388,388,388,388,184,185,388,388,194,195,196,388,151,157,145,132,388,389,
        389,389,389,389,389,389,389,389,389,389,389,389,389,389,389,389,389,389,389,151,157,145,
        389,389,292,279,302,290,302,384,292,292,292,290,290,290,194,195,196,194,195,196,145,132,
        384,145,132,306,279,306,306,304,306,304,303,301,303,301,384,280,194,195,196,194,195,196,
        145,132,384,145,132,306,384,306,308,300,308,300,384,299,207,299,280,384,194,195,196,308,
        308,308,145,132,384,308,308,390,390,390,390,390,390,390,390,390,390,390,390,390,390,390,
        390,390,390,390,390,390,390,390,132,390,307,274,307,306,296,306,296,294,276,294,384,275,
        277,307,307,307,194,195,196,307,307,287,145,132,274,384,132,184,185,132,277,194,195,196,
        384,151,157,145,132,391,391,391,219,391,168,391,391,391,391,391,391,391,391,391,391,391,
        391,391,391,391,391,391,391,391,317,384,384,278,384,384,317,317,273,384,317,317,317,288,
        317,317,317,317,384,288,288,278,384,288,288,288,318,288,288,288,288,273,318,318,384,384,
        318,318,318,384,318,318,318,318,227,227,227,227,227,227,227,227,227,227,282,227,227,227,
        227,227,227,227,227,227,227,227,227,227,285,285,285,285,285,285,285,285,285,285,285,285,
        285,285,285,285,285,285,285,285,285,285,285,285,227,227,227,227,227,227,227,227,227,227,
        281,227,227,227,227,227,227,227,227,227,227,227,227,227,283,283,283,283,283,283,283,283,
        283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,284,284,284,284,284,284,
        284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,272,384,384,384,
        384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,272
    ];
    const ubyte[]  goto_base =
    [
        0,0,0,1,0,0,0,0,3,0,0,5,6,0,0,0,8,0,0,0,0,0,0,0,5,0,0,13,0,0,14,0,0,0,0,0,0,0,0,11,0,0,10,
        14,0,0,0,0,0,0,40,0,1,35,21,50,0,0,0,62,66,0,0,0,0,0,73,81,0,28,0,89,0,0,97,0,105,0,0,29,0,
        0,113,0,0,0,0,0,127,0,51,0,0,0,0,0,0,0,1,0,0,128,6,0,36,0,0,4,0,0,0,0
    ];
    const ubyte[]  goto_check =
    [
        0,0,22,22,112,112,2,2,2,11,11,12,52,98,98,98,27,102,107,112,57,112,112,112,22,22,22,22,2,3,
        3,8,24,11,12,16,16,27,27,27,27,30,39,39,42,43,43,43,50,43,53,53,54,54,53,69,53,79,53,53,53,
        53,53,53,104,55,55,112,50,55,112,55,112,55,55,55,55,55,55,59,59,90,90,90,60,112,59,59,59,
        59,60,60,60,60,66,112,66,112,112,66,66,66,67,112,67,112,112,67,67,67,71,71,71,112,112,71,
        71,71,74,74,74,112,112,74,74,74,76,76,76,112,112,76,76,76,82,82,82,101,101,82,82,82,88,88,
        112,112,88,112,88,112,88,88,88,88,88,88,101
    ];
    const ubyte[]  goto_data =
    [
        1,2,27,38,112,112,49,50,111,12,20,14,110,100,107,109,33,103,108,112,59,112,112,112,34,35,36,
        37,52,5,6,9,25,15,15,18,19,34,35,36,37,31,41,42,43,46,42,47,51,48,96,88,55,42,90,81,94,80,
        74,34,95,76,37,78,105,86,88,112,52,90,112,94,112,74,34,95,76,37,78,60,65,92,93,42,62,112,
        34,63,64,37,34,63,64,37,85,112,74,112,112,76,37,78,84,112,74,112,112,76,37,78,72,73,74,112,
        112,76,37,78,72,75,74,112,112,76,37,78,72,77,74,112,112,76,37,78,72,83,74,102,104,76,37,78,
        89,88,112,112,90,112,94,112,74,34,95,76,37,78,106
    ];

    debug(parser) string indent;
    
    this(GLRParser ws=null)
    {
        super(ws);
        lexer = &mainLexer;
        first_nt = 28;
        nt_names =
        [
            "Start","Prolog","Lexs","Lexeme","Props","Property","Grammar","NTs","NT","AttribsOpt",
            "Attributes","NTBody","DParametersOpt","DParameters","DParam","Rules","Rule",
            "TerminalList","Terminal","Symbols","NegateOpt","TNTSymbols","OptTNTSymbols",
            "NonTerminal","RegExp","RegExpTerminal","StringTerminal","QuotedString","Ident",
            "FQIdent","RuleBody","DCodeBlock","OpenCurly","CloseCurly","DCode","DCodeSegment",
            "!LRstart"
        ];
        lexeme_names =
        [
            "EOS","[,\\.\\*/\\+\\-%$~\\|&~'\\\\\"0-9<\\>\\?:]","import",";","Properties","\\{",
            "\\}","Lexemes","Declaration","=","\\(","\\)","epsilon","\\[","\\]","\\^","KeepWS",
            "SkipWS","!","sync","regexp","regexpi",
            "\"([^\"\\\\]*(\\\\([^xuU]|(x[0-9a-fA-F]{2})|(u[0-9a-fA-F]{4})|(U[0-9a-fA-F]{8})))?)*\"",
            "[a-zA-Z_][a-zA-Z0-9_]*","\\."
        ];
        entry_infos =
        [
            cast(EntryInfo[])[EntryInfo(5,0)],[EntryInfo(70,1)],[EntryInfo(0,1),EntryInfo(1,1),EntryInfo(2,1)
            ,EntryInfo(3,1),EntryInfo(4,1)],[EntryInfo(1,2)],[EntryInfo(58,1)],[EntryInfo(60,1)],[EntryInfo(1,3)
            ,EntryInfo(59,1)],[EntryInfo(1,4)],[EntryInfo(59,2)],[EntryInfo(59,3)],[EntryInfo(2,2)],[
            EntryInfo(2,3)],[EntryInfo(2,4),EntryInfo(10,1)],[EntryInfo(2,5)],[EntryInfo(10,2)],[EntryInfo(12,1)
            ,EntryInfo(13,1)],[EntryInfo(12,2),EntryInfo(13,2)],[EntryInfo(57,1)],[EntryInfo(13,3)],[
            EntryInfo(12,3)],[EntryInfo(11,1)],[EntryInfo(3,2)],[EntryInfo(3,3)],[EntryInfo(53,1)],[
            EntryInfo(53,2)],[EntryInfo(53,3)],[EntryInfo(53,4)],[EntryInfo(3,4),EntryInfo(6,1)],[EntryInfo(3,5)],[
            EntryInfo(54,1)],[EntryInfo(54,2)],[EntryInfo(54,3)],[EntryInfo(54,4)],[EntryInfo(6,2)],[
            EntryInfo(55,1)],[EntryInfo(9,1)],[EntryInfo(8,1)],[EntryInfo(56,1)],[EntryInfo(7,1)],[EntryInfo(4,2)],[
            EntryInfo(64,1)],[EntryInfo(4,3)],[EntryInfo(63,1),EntryInfo(67,0)],[EntryInfo(63,2),EntryInfo(66,1)],[
            EntryInfo(69,1)],[EntryInfo(65,1)],[EntryInfo(68,1)],[EntryInfo(63,3)],[EntryInfo(66,2)],[
            EntryInfo(0,2)],[EntryInfo(14,1),EntryInfo(15,1)],[EntryInfo(15,2)],[EntryInfo(17,1),EntryInfo(18,1)],[
            EntryInfo(23,1),EntryInfo(24,1),EntryInfo(31,0)],[EntryInfo(23,2)],[EntryInfo(23,3),EntryInfo(31,0)],[
            EntryInfo(37,1)],[EntryInfo(39,1),EntryInfo(42,0)],[EntryInfo(41,1)],[EntryInfo(39,2)],[
            EntryInfo(39,3),EntryInfo(33,1)],[EntryInfo(39,4)],[EntryInfo(33,2)],[EntryInfo(35,1)],[
            EntryInfo(36,1)],[EntryInfo(34,1)],[EntryInfo(43,1)],[EntryInfo(44,1)],[EntryInfo(45,1),EntryInfo(46,1)],[
            EntryInfo(45,2),EntryInfo(46,2)],[EntryInfo(46,3)],[EntryInfo(46,4),EntryInfo(50,0)],[EntryInfo(49,1)],[
            EntryInfo(46,5)],[EntryInfo(48,1),EntryInfo(50,0)],[EntryInfo(48,2)],[EntryInfo(47,1),EntryInfo(50,0)],[
            EntryInfo(47,2)],[EntryInfo(51,1),EntryInfo(52,1)],[EntryInfo(51,2)],[EntryInfo(51,3)],[
            EntryInfo(45,3)],[EntryInfo(45,4),EntryInfo(50,0)],[EntryInfo(45,5)],[EntryInfo(44,2)],[
            EntryInfo(43,2)],[EntryInfo(23,4)],[EntryInfo(23,5)],[EntryInfo(30,1),EntryInfo(31,0)],[
            EntryInfo(30,2)],[EntryInfo(32,1)],[EntryInfo(61,1)],[EntryInfo(32,2)],[EntryInfo(62,1)],[
            EntryInfo(40,1)],[EntryInfo(38,1)],[EntryInfo(24,2)],[EntryInfo(24,3)],[EntryInfo(18,2),EntryInfo(26,0)],[
            EntryInfo(29,1)],[EntryInfo(18,3)],[EntryInfo(18,4),EntryInfo(20,0)],[EntryInfo(18,5)],[
            EntryInfo(18,6)],[EntryInfo(19,1),EntryInfo(21,1)],[EntryInfo(21,2)],[EntryInfo(22,1)],[
            EntryInfo(25,1),EntryInfo(27,1)],[EntryInfo(27,2)],[EntryInfo(28,1)],[EntryInfo(17,2)],[
            EntryInfo(16,1)]
        ];
        rule_infos =
        [
            RuleInfo(true,2,2,0,[4097,4102]),RuleInfo(true,4,2,1,[4097,5,4125,6]),
            RuleInfo(true,5,2,1,[4097,7,8,4100,9]),RuleInfo(true,5,2,1,[4097,10,8,4098,9]),
            RuleInfo(true,3,2,1,[4097,11,4127]),RuleInfo(true,0,0,1,[]),RuleInfo(true,2,2,2,[4098,4099]),
            RuleInfo(true,1,1,2,[4099]),RuleInfo(true,1,1,3,[4122]),RuleInfo(true,1,1,3,[4121]),
            RuleInfo(true,2,2,4,[4100,4101]),RuleInfo(true,1,1,4,[4101]),RuleInfo(true,3,2,5,[4124,12,4124]),
            RuleInfo(true,3,2,5,[4124,12,4123]),RuleInfo(true,1,1,6,[4103]),RuleInfo(true,2,2,7,[4103,4104]),
            RuleInfo(true,1,1,7,[4104]),RuleInfo(true,2,2,8,[4124,4107]),
            RuleInfo(true,6,4,8,[4124,13,4108,14,4105,4107]),RuleInfo(true,1,1,9,[4106]),
            RuleInfo(true,0,0,9,[]),RuleInfo(true,2,2,10,[4106,4124]),RuleInfo(true,1,1,10,[4124]),
            RuleInfo(true,5,2,11,[8,11,4127,4111,9]),RuleInfo(true,3,1,11,[8,4111,9]),
            RuleInfo(true,1,1,12,[4109]),RuleInfo(true,0,0,12,[]),RuleInfo(true,2,2,13,[4109,4110]),
            RuleInfo(true,1,1,13,[4110]),RuleInfo(true,1,0,14,[2]),RuleInfo(true,2,2,15,[4112,4111]),
            RuleInfo(true,0,0,15,[]),RuleInfo(true,2,2,16,[4115,4126]),RuleInfo(true,2,2,17,[4113,4114]),
            RuleInfo(true,1,1,17,[4114]),RuleInfo(true,1,1,18,[4121]),RuleInfo(true,1,1,18,[4122]),
            RuleInfo(true,1,0,19,[15]),RuleInfo(true,1,1,19,[4121]),RuleInfo(true,4,2,19,[16,4116,4113,17]),
            RuleInfo(true,1,1,19,[4117]),RuleInfo(true,1,0,20,[18]),RuleInfo(true,0,0,20,[]),
            RuleInfo(true,2,1,21,[19,4117]),RuleInfo(true,2,1,21,[20,4117]),
            RuleInfo(true,5,2,21,[21,13,4123,14,4118]),RuleInfo(true,5,1,21,[21,13,22,14,4118]),
            RuleInfo(true,2,2,21,[4122,4118]),RuleInfo(true,2,2,21,[4119,4118]),RuleInfo(true,1,1,22,[4117]),
            RuleInfo(true,0,0,22,[]),RuleInfo(true,3,2,23,[4124,12,4124]),RuleInfo(true,1,1,23,[4124]),
            RuleInfo(true,4,1,24,[23,13,4123,14]),RuleInfo(true,4,1,24,[24,13,4123,14]),
            RuleInfo(true,1,1,25,[4120]),RuleInfo(true,1,1,26,[4123]),RuleInfo(true,1,0,27,[25]),
            RuleInfo(true,1,0,28,[26]),RuleInfo(true,3,2,29,[4125,27,4124]),RuleInfo(true,1,1,29,[4124]),
            RuleInfo(true,1,0,30,[6]),RuleInfo(true,1,1,30,[4127]),RuleInfo(true,3,3,31,[4128,4130,4129]),
            RuleInfo(true,1,0,32,[8]),RuleInfo(true,1,0,33,[9]),RuleInfo(true,2,2,34,[4130,4131]),
            RuleInfo(true,0,0,34,[]),RuleInfo(true,1,1,35,[4127]),RuleInfo(true,1,0,35,[2]),
            RuleInfo(true,1,1,36,[4096])
        ];
        error_message_lists = [
            cast(string[])null,
            ["Regular expression expected after regexp keyword"],
            ["Non-terminal declaration expected"],
            ["Rules or DCodeBlock expected after {"],
            ["Rules expected after DCodeBLock"],
            ["TerminalList expected after ["],
            ["Identifier expected after aliasing Operator"],
            ["Body for rule expected after symbol list"]
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base[state];
        foreach ( i, check; action_check[b .. APDmin($, b+first_nt)] )
        {
            if ( check == state && (action_data[b+i] & 384) == 256 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool parse(ref string input, uint line_number, uint symbol, bool fatalErrors)
    {
        debug(parser) indent ~= " ";
        scope(exit) debug(parser) indent = indent[0..$-1];

        bool shiftBranch(uint state)
        {
            ++branches;
            debug(parser) writefln("%sshift %d\nbranch conflict", indent, state);
            auto stack_bkp = stack.dup;
            auto node_stack_bkp = node_stack.dup;
            auto input_bkp = input;
            auto lookahead_bkp = lookahead;
            auto lookahead_ws_bkp = lookahead_ws;
            stack ~= LRState(state, line_number);
            if ( parse(input, line_number, 0, false) )
                return true;

            stack = stack_bkp;
            node_stack = node_stack_bkp;
            input = input_bkp;
            lookahead = lookahead_bkp;
            lookahead_ws = lookahead_ws_bkp;
            return false;
        }

        void reduce(uint rule)
        {
            debug(parser) writefln("%sreduce %d", indent, rule);
            auto ri = &rule_infos[rule];
            uint reduce_line_number;
            if ( ri.symbol_count > 0 ) {
                reduce_line_number = stack.array[$-ri.symbol_count].line_number;
                stack.pop(ri.symbol_count);
            }
            else
                reduce_line_number = stack.array[$-1].line_number;

            auto b = goto_base[stack.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check.length && goto_check[b] == stack.top.index ) {
                    stack ~= LRState(goto_data[b], reduce_line_number);
                    writefln("%sgoto %d", indent, stack.top.index);
                }
                else
                    assert(0);
            }
            else
                stack ~= LRState(goto_data[b], reduce_line_number);
            if ( ri.ast_node ) {
                debug createNode(reduce_line_number, rule, ri.nt_count, ri.nt_index);
                else createNode(reduce_line_number, rule, ri.nt_count);
            }
            else if ( ri.nt_count > 0 )
                node_stack.pop(ri.nt_count);
        }

        bool reduceBranch(uint rule)
        {
            ++branches;
            debug(parser) writefln("%sbranch conflict", indent);

            auto stack_bkp = stack.dup;
            auto node_stack_bkp = node_stack.dup;
            auto input_bkp = input;
            auto lookahead_bkp = lookahead;
            auto lookahead_ws_bkp = lookahead_ws;

            reduce(rule);
            if ( parse(input, line_number, symbol, false) )
                return true;

            stack = stack_bkp;
            node_stack = node_stack_bkp;
            input = input_bkp;
            lookahead = lookahead_bkp;
            lookahead_ws = lookahead_ws_bkp;
            return false;
        }

        bool isErrorSynced(uint state)
        {
            switch ( state )
            {
                case 0:
                    return true;
                default:
                    break;
            }
            return false;
        }
        
        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( isErrorSynced(stack.top.index) )
            {
                if ( node_stack.length > 0 )
                    node_stack.array[$-1].sync = true;
                fatalErrors = true;
            }

            if ( symbol == 0 )
            {
                match = lookahead;
                match_ws = lookahead_ws;
                symbol = readSymbol(input, line_number, stack.top.index);
                if ( symbol == 0 )
                    throw new ParserException(line_number, filename, "Invalid token", input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$]);
                prev_input = input;
                input = input[lookahead.length..$];
            }
            debug(parser)
            {
                string node_stack_str;
                foreach ( n; node_stack.array )
                    node_stack_str ~= " "~n.node._ST_node_name~(n.sync?"*":"");
                writefln("\n%snodes %s\n%slkahd (%d) %s\n%sinput (%d) %s",
                    indent, node_stack_str,
                    indent, symbol, lookahead,
                    indent, line_number, replace(replace(input[0..$>MAX_INPUT_DUMP?MAX_INPUT_DUMP:$], "\r", "\\r"), "\n", "\\n")
                );
            }

            auto state = stack.top.index;
            auto b = action_base[state];
            ushort action = 384;
            b += symbol-EOS;
            if ( b < action_check.length && action_check[b] == state )
                action = action_data[b];

            switch ( action & 384 )
            {
                case 128:
                    action &= 127;
                    debug(parser) writefln("%sshift %d", indent, action);
                    stack ~= LRState(action, line_number);
                    symbol = 0;
                    continue parseLoop;
                case 256:
                    action &= 127;
                    debug(parser) writefln("%sreduce %d", indent, action);
                    auto ri = &rule_infos[action];
                    uint reduce_line_number;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line_number = stack.array[$-ri.symbol_count].line_number;
                        stack.pop(ri.symbol_count);
                    }
                    else
                        reduce_line_number = stack.array[$-1].line_number;

                    state = stack.top.index;
                    b = goto_base[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check.length && goto_check[b] == state ) {
                            stack ~= LRState(goto_data[b], reduce_line_number);
                            writefln("%sgoto %d", indent, stack.top.index);
                        }
                        else
                            assert(0);
                    }
                    else
                        stack ~= LRState(goto_data[b], reduce_line_number);
                    if ( ri.ast_node ) {
                        debug createNode(reduce_line_number, action, ri.nt_count, ri.nt_index);
                        else createNode(reduce_line_number, action, ri.nt_count);
                    }
                    else if ( ri.nt_count > 0 )
                        node_stack.pop(ri.nt_count);

                    continue parseLoop;
                case 384:
                    action &= 127;
                    if ( fatalErrors || action > 0 )
                    {
                        if ( recover_from_errors )
                        {
                            try error(prev_input, line_number, action, symbol);
                            catch ( ParserException e )
                                recovered_errors ~= e;
                            debug(nonfatal) writefln("recovering from error:\n%s", recovered_errors[$-1]);
                            while ( !stack.empty && !isErrorSynced(stack.top.index) )
                                stack.pop;
                            while ( !node_stack.empty && !node_stack.top.sync )
                                node_stack.pop;
                            symbol = 0;
                            continue parseLoop;
                        }
                        else {
                            input = prev_input;
                            error(input, line_number, action, symbol);
                        }
                    }
                    else {
                        input = prev_input;
                        debug(nonfatal) error(input, line_number, action, symbol, false);
                    }
                    return false;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    debug(parser) writefln("%saccept", indent);
                    syntax_root = node_stack.top.node;
                    input = prev_input;
                    return true;
                default:
                    assert(0);
            }
        }
        assert(0);
    }
}

class WhitespaceGrammar : GLRParser
{
    const ubyte[]  action_base =
    [
        0,4,8,12,16,20,24
    ];
    const ubyte[]  action_check =
    [
        7,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6
    ];
    const ubyte[]  action_data =
    [
        24,9,10,11,18,18,18,18,19,19,19,19,20,20,20,20,0,9,10,11,16,16,16,16,17,17,17,17
    ];
    const ubyte[]  goto_base =
    [
        0,0,0,0,1,0,0
    ];
    const ubyte[]  goto_check =
    [
        0,0,4
    ];
    const ubyte[]  goto_data =
    [
        4,6,5
    ];

    debug(parser) string indent;
    
    this(GLRParser ws=null)
    {
        super(ws);
        lexer = &wsLexer;
        first_nt = 7;
        nt_names =
        [
            "Whitespace","WhitespaceFlat","!LRstart"
        ];
        lexeme_names =
        [
            "EOS","/\\*([^\\*]|\\*>/)*\\*/","//[^\\n]*\\n","[\\n\\r\\t ]+"
        ];
        entry_infos =
        [
            cast(EntryInfo[])[],[EntryInfo(2,1)],[EntryInfo(3,1)],[EntryInfo(4,1)],[EntryInfo(5,1),EntryInfo(0,1)],[
            EntryInfo(0,2)],[EntryInfo(1,1)]
        ];
        rule_infos =
        [
            RuleInfo(true,2,2,0,[4096,4097]),RuleInfo(true,1,1,0,[4097]),RuleInfo(true,1,0,1,[4]),
            RuleInfo(true,1,0,1,[5]),RuleInfo(true,1,0,1,[6]),RuleInfo(true,1,1,2,[4096])
        ];
        error_message_lists = [
            cast(string[])null
        ];
    }

    uint[] lookaheadForNT(uint nt_index, uint state)
    {
        uint[] tokens;
        auto b = action_base[state];
        foreach ( i, check; action_check[b .. APDmin($, b+first_nt)] )
        {
            if ( check == state && (action_data[b+i] & 24) == 16 )
                tokens ~= i+EOS;
        }
        return tokens;
    }

    override bool parse(ref string input, uint line_number, uint symbol, bool fatalErrors)
    {
        debug(parser) indent ~= " ";
        scope(exit) debug(parser) indent = indent[0..$-1];

        bool shiftBranch(uint state)
        {
            ++branches;
            auto stack_bkp = stack.dup;
            auto node_stack_bkp = node_stack.dup;
            auto input_bkp = input;
            auto lookahead_bkp = lookahead;
            auto lookahead_ws_bkp = lookahead_ws;
            stack ~= LRState(state, line_number);
            if ( parse(input, line_number, 0, false) )
                return true;

            stack = stack_bkp;
            node_stack = node_stack_bkp;
            input = input_bkp;
            lookahead = lookahead_bkp;
            lookahead_ws = lookahead_ws_bkp;
            return false;
        }

        void reduce(uint rule)
        {
            debug(parser) writefln("%sreduce %d", indent, rule);
            auto ri = &rule_infos[rule];
            uint reduce_line_number;
            if ( ri.symbol_count > 0 ) {
                reduce_line_number = stack.array[$-ri.symbol_count].line_number;
                stack.pop(ri.symbol_count);
            }
            else
                reduce_line_number = stack.array[$-1].line_number;

            auto b = goto_base[stack.top.index];
            b += ri.nt_index;
            debug(parser)
            {
                if ( b < goto_check.length && goto_check[b] == stack.top.index ) {
                    stack ~= LRState(goto_data[b], reduce_line_number);
                }
                else
                    assert(0);
            }
            else
                stack ~= LRState(goto_data[b], reduce_line_number);
        }

        bool reduceBranch(uint rule)
        {
            ++branches;
            debug(parser) writefln("%sbranch conflict", indent);

            auto stack_bkp = stack.dup;
            auto node_stack_bkp = node_stack.dup;
            auto input_bkp = input;
            auto lookahead_bkp = lookahead;
            auto lookahead_ws_bkp = lookahead_ws;

            reduce(rule);
            if ( parse(input, line_number, symbol, false) )
                return true;

            stack = stack_bkp;
            node_stack = node_stack_bkp;
            input = input_bkp;
            lookahead = lookahead_bkp;
            lookahead_ws = lookahead_ws_bkp;
            return false;
        }

        bool isErrorSynced(uint state)
        {
            switch ( state )
            {
                case 0:
                    return true;
                default:
                    break;
            }
            return false;
        }
        
        string prev_input = input;
        parseLoop: while ( true )
        {
            if ( isErrorSynced(stack.top.index) )
            {
                if ( node_stack.length > 0 )
                    node_stack.array[$-1].sync = true;
                fatalErrors = true;
            }

            if ( symbol == 0 )
            {
                match = lookahead;
                match_ws = lookahead_ws;
                symbol = readSymbol(input, line_number, stack.top.index);
                if ( symbol == 0 )
                    return false;
                prev_input = input;
                input = input[lookahead.length..$];
            }

            auto state = stack.top.index;
            auto b = action_base[state];
            ubyte action = 24;
            b += symbol-EOS;
            if ( b < action_check.length && action_check[b] == state )
                action = action_data[b];

            switch ( action & 24 )
            {
                case 8:
                    action &= 7;
                    stack ~= LRState(action, line_number);
                    symbol = 0;
                    continue parseLoop;
                case 16:
                    action &= 7;
                    auto ri = &rule_infos[action];
                    uint reduce_line_number;
                    if ( ri.symbol_count > 0 ) {
                        reduce_line_number = stack.array[$-ri.symbol_count].line_number;
                        stack.pop(ri.symbol_count);
                    }
                    else
                        reduce_line_number = stack.array[$-1].line_number;

                    state = stack.top.index;
                    b = goto_base[state];
                    b += ri.nt_index;
                    debug(parser)
                    {
                        if ( b < goto_check.length && goto_check[b] == state ) {
                            stack ~= LRState(goto_data[b], reduce_line_number);
                        }
                        else
                            assert(0);
                    }
                    else
                        stack ~= LRState(goto_data[b], reduce_line_number);

                    continue parseLoop;
                case 24:
                    action &= 7;
                    input = prev_input;
                    return false;
                default:
                    break;
            }

            switch ( action )
            {
                case 0:
                    input = prev_input;
                    return true;
                default:
                    assert(0);
            }
        }
        assert(0);
    }
}


// generated code end
